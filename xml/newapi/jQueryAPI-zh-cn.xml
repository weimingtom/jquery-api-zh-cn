<?xml version="1.0" encoding="UTF-8"?>
<api>
   <categories>
      <category name="Ajax" zh="Ajax">
         <category name="Global Ajax Event Handlers" zh="全局Ajax事件"/>
         <category name="Helper Functions" zh="辅助函数"/>
         <category name="Low-Level Interface" zh="底层接口"/>
         <category name="Shorthand Methods" zh="快捷方法"/>
      </category>
      <category name="Attributes" zh="属性"/>
      <category name="Core" zh="核心"/>
      <category name="CSS" zh="CSS"/>
      <category name="Data" zh="数据"/>
      <category name="Dimensions" zh="尺寸"/>
      <category name="Effects" zh="效果">
         <category name="Basics" zh="基本"/>
         <category name="Custom" zh="自定义"/>
         <category name="Fading" zh="渐变"/>
         <category name="Sliding" zh="滑动"/>
      </category>
      <category name="Events" zh="事件">
         <category name="Browser Events" zh="浏览器事件"/>
         <category name="Document Loading" zh="文档加载"/>
         <category name="Event Handler Attachment" zh="事件处理"/>
         <category name="Event Object" zh="事件对象"/>
         <category name="Form Events" zh="表单事件"/>
         <category name="Keyboard Events" zh="键盘事件"/>
         <category name="Mouse Events" zh="鼠标事件"/>
      </category>
      <category name="Forms" zh="表单"/>
      <category name="Manipulation" zh="操作">
         <category name="Class Attribute" zh="Class属性"/>
         <category name="Copying" zh="复制"/>
         <category name="DOM Insertion" zh="DOM插入"/>
         <category name="DOM Insertion, Around" zh="包裹"/>
         <category name="DOM Insertion, Inside" zh="内部插入"/>
         <category name="DOM Insertion, Outside" zh="外部插入"/>
         <category name="DOM Removal" zh="DOM删除"/>
         <category name="DOM Replacement" zh="DOM替换"/>
         <category name="General Attributes" zh="通用属性"/>
         <category name="Style Properties" zh="样式属性"/>
      </category>
      <category name="Miscellaneous" zh="杂项">
         <category name="Collection Manipulation" zh="集合操作"/>
         <category name="Data Storage" zh="数据存储"/>
         <category name="DOM Element Methods" zh="DOM元素方法"/>
         <category name="Setup Methods" zh="设置方法"/>
      </category>
      <category name="Offset" zh="偏移"/>
      <category name="Plugin Authoring" zh="插件编写"/>
      <category name="Properties" zh="属性">
         <category name="Properties of jQuery Object Instances" zh="jQuery对象实例属性"/>
         <category name="Properties of the Global jQuery Object" zh="全局jQuery对象属性"/>
      </category>
      <category name="Selectors" zh="选择器">
         <category name="Attribute" zh="属性"/>
         <category name="Basic" zh="基础"/>
         <category name="Basic Filter" zh="简单"/>
         <category name="Child Filter" zh="子元素"/>
         <category name="Content Filter" zh="内容"/>
         <category name="Form" zh="表单"/>
         <category name="Hierarchy" zh="层级"/>
         <category name="Visibility Filter" zh="可见性"/>
      </category>
      <category name="Traversing" zh="遍历">
         <category name="Filtering" zh="筛选"/>
         <category name="Miscellaneous Traversing" zh="其他遍历"/>
         <category name="Tree Traversal" zh="树遍历"/>
      </category>
      <category name="Utilities" zh="工具"/>
      <category name="Version" zh="版本">
         <category name="Version 1.0" zh="1.0 版"/>
         <category name="Version 1.0.4" zh="1.0.4 版"/>
         <category name="Version 1.1" zh="1.1 版"/>
         <category name="Version 1.1.2" zh="1.1.2 版"/>
         <category name="Version 1.1.3" zh="1.1.3 版"/>
         <category name="Version 1.1.4" zh="1.1.4 版"/>
         <category name="Version 1.2" zh="1.2 版"/>
         <category name="Version 1.2.3" zh="1.2.3 版"/>
         <category name="Version 1.2.6" zh="1.2.6 版"/>
         <category name="Version 1.3" zh="1.3 版"/>
         <category name="Version 1.4" zh="1.4 版"/>
         <category name="Version 1.4.1" zh="1.4.1 版"/>
         <category name="Version 1.4.2" zh="1.4.2 版"/>
      </category>
  </categories>
   <entries>
      <entry type="method" name="undelegate">
         <desc>Remove a handler from the event for all elements which match the current selector, now or in the future, based upon a specific set of root elements.</desc>
         <signature/>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="eventType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="eventType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="handler">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Undelegate is a way of removing event handlers that have been bound using <a href="/delegate">.delegate()</a>. It works virtually identically to <a href="/die">.die()</a> with the addition of a selector filter argument (which is required for delegation to work).</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="delegate">
         <desc>Attach a handler to one or more events for all elements that match the selector, now or in the future, based on a specific set of root elements.</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="eventType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="handler">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="eventType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="eventData">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="handler">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Delegate is an alternative to using the <a href="/live">.live()</a> method, allowing for each binding of event delegation to specific DOM elements. For example the following delegate code:</p>

            <pre>$("table").delegate("td", "hover", function(){
	$(this).toggleClass("hover");
});</pre>

            <p>Is equivalent to the following code written using <code>.live()</code>:</p>

            <pre>$("table").each(function(){
	$("td", this).live("hover", function(){
		$(this).toggleClass("hover");
	});
});</pre>

            <p>See also the <a href="/undelegate">.undelegate()</a> method for a way of removing event handlers added in <a href="/delegate">.delegate()</a>.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.error">
         <desc>接受一个字符串，并且直接抛出一个包含这个字符串的异常。</desc>
         <signature>
            <argument name="message">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个方法的主要目的是提供给插件开发人员，让他们可以重载这个方法，并以更好的方式显示错误，或者提供更多信息。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.parseJSON">
         <desc>接受一个JSON字符串，返回解析后的对象。</desc>
         <signature>
            <argument name="json">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>传入一个畸形的JSON字符串会抛出一个异常。比如下面的都是畸形的JSON字符串：
		
&lt;ul&gt;
	&lt;li&gt;{test: 1} （ test 没有包围双引号）&lt;/li&gt;
	&lt;li&gt;{'test': 1} （使用了单引号而不是双引号）&lt;/li&gt;
&lt;/ul&gt;

另外，如果你什么都不传入，或者一个空字符串、null或undefined，parseJSON都会返回 null 。
		</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.proxy">
         <desc>jQuery 1.4 新增。返回一个新函数，并且这个函数始终保持了特定的作用域。</desc>
         <signature>
            <argument name="function">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="context">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="context">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="name">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>当有事件处理函数要附加到元素上，但他们的作用域实际是指向另一个对象时，这个方法最有用了。此外，最妙的是，jQuery能够确保即便你绑定的函数是经过jQuery.proxy()处理过的函数，你依然可以传递原先的函数来准确无误地取消绑定。请参考下面的例子。
		
		这个函数还有另一种用法，jQuery.proxy( scope, name )。第一个参数是要设定的作用域对象。第二个参数是将要设置作用域的函数名（必须是第一个作用域对象的一个属性）。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="focusout">
         <desc>在每一个匹配元素的focusout事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>当一个元素，或者其内部任何一个元素失去焦点的时候会触发这个事件。这跟blur事件区别在于，他可以在父元素上检测子元素失去焦点的情况。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="focusin">
         <desc>在每一个匹配元素的focusin事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>当一个元素，或者其内部任何一个元素获得焦点的时候会触发这个事件。这跟focus事件区别在于，他可以在父元素上检测子元素获取焦点的情况。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="has">
         <desc>保留包含特定后代的元素，去掉那些不含有指定后代的元素。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="contained">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>.has()方法将会从给定的jQuery对象中重新创建一组匹配的对象。提供的选择器会一一测试原先那些对象的后代，含有匹配后代的对象将得以保留。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.contains">
         <desc>jQuery 1.4 新增。一个DOM节点是否包含另一个DOM节点。</desc>
         <signature>
            <argument name="container">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="contained">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.noop">
         <desc>An empty function.</desc>
         <signature/>
         <longdesc>
            <p>You can use this empty function when you wish to pass around a function that will do nothing.</p>
            <p>This is useful for plugin authors who offer optional callbacks; in the case that no callback is given, something like <code>jQuery.noop</code> could execute.</p>
         </longdesc>
      </entry>
      <entry type="method" name="delay">
         <desc>设置一个延时来推迟执行队列中之后的项目。</desc>
         <signature>
            <argument name="duration">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="queueName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>jQuery 1.4新增。用于将队列中的函数延时执行。他既可以推迟动画队列的执行，也可以用于自定义队列。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="parentsUntil">
         <desc>查找当前元素的所有的父辈元素，直到遇到匹配的那个元素为止。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果提供的jQuery代表了一组DOM元素，.parentsUntil()方法也能让我们找遍所有元素的祖先元素，直到遇到了一个跟提供的参数匹配的元素的时候才会停下来。这个返回的jQuery对象里包含了下面所有找到的父辈元素，但不包括那个选择器匹配到的元素。
		
		</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="prevUntil">
         <desc>查找当前元素之前所有的同辈元素，直到遇到匹配的那个元素为止。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果提供的jQuery代表了一组DOM元素，.prevUntil()方法也能让我们找遍所有元素所在的DOM树，直到遇到了一个跟提供的参数匹配的元素的时候才会停下来。这个新jQuery对象里包含了前面所有找到的同辈元素，但不包括那个选择器匹配到的元素。
		
		如果没有选择器匹配到，或者没有提供参数，那么排在前面的所有同辈元素都会被选中。这就跟用没有提供参数的 .prevAll()效果一样。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="nextUntil">
         <desc>查找当前元素之后所有的同辈元素，直到遇到匹配的那个元素为止。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果提供的jQuery代表了一组DOM元素，.nextUntil()方法也能让我们找遍所有元素所在的DOM树，直到遇到了一个跟提供的参数匹配的元素的时候才会停下来。这个新jQuery对象里包含了下面所有找到的同辈元素，但不包括那个选择器匹配到的元素。
		
		如果没有选择器匹配到，或者没有提供参数，那么跟在后面的所有同辈元素都会被选中。这就跟用没有提供参数的 .nextAll()效果一样。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="event.isImmediatePropagationStopped">
         <desc>  Returns whether event.stopImmediatePropagation() was ever called on this event object. </desc>
         <signature/>
         <longdesc> 
            <p>This property was introduced in <a href="http://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107/events.html#Events-Event-isImmediatePropagationStopped">DOM level 3</a>.</p>  
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="event.stopImmediatePropagation">
         <desc> Keeps the rest of the handlers from being executed and prevents the event from bubbling up the DOM tree
  </desc>
         <signature/>
         <longdesc>
            <p>In addition to keeping any additional handlers on an element from being executed, this method also stops the bubbling by implicitly calling <code>event.stopPropagation()</code>. To simply prevent the event from bubbling to ancestor elements but allow other event handlers to execute on the same element, we can use <code>
                  <a href="http://api.jquery.com/event.stopPropagation">event.stopPropagation()</a>
               </code> instead.</p>
            <p>Use <code>
                  <a href="http://api.jquery.com/event.isImmediatePropagationStopped">event.isImmediatePropagationStopped()</a>
               </code> to know whether this method was ever called (on that event object).</p> 
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="event.isPropagationStopped">
         <desc>  Returns whether event.stopPropagation() was ever called on this event object. </desc>
         <signature/>
         <longdesc>
            <p>This event method is described in the <a href="http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/events.html#Events-Event-isPropagationStopped">W3C DOM Level 3 specification</a>.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="event.stopPropagation">
         <desc>Prevents the event from bubbling up the DOM tree, preventing any parent handlers from being notified of the event.   </desc>
         <signature/>
         <longdesc>  
            <p>We can use <code>
                  <a href="/event.isPropagationStopped">event.isPropagationStopped()</a>
               </code> to determine if this method was ever called (on that event object). </p>
            <p>This method works for custom events triggered with <a href="/trigger">trigger()</a>, as well.</p>
            <p>Note that this will not prevent other handlers <em>on the same element</em> from running. </p> 
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="event.isDefaultPrevented">
         <desc>Returns whether event.preventDefault() was ever called on this event object. </desc>
         <signature/>
         <longdesc>   </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="event.preventDefault">
         <desc> If this method is called, the default action of the event will not be triggered. </desc>
         <signature/>
         <longdesc> 
            <p>For example, clicked anchors will not take the browser to a new URL. We can use <code>event.isDefaultPrevented()</code> to determine if this method has been called by an event handler that was triggered by this event.</p>  
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="event.timeStamp">
         <desc> This attribute returns the number of milliseconds since January 1, 1970, when the event is triggered.   </desc>
         <signature/>
         <longdesc>It can be useful for profiling the performance of certain jQuery functions. </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="event.result">
         <desc> This attribute contains the last value returned by an event handler that was triggered by this event, unless the value was undefined.  </desc>
         <signature/>
         <longdesc> It can be useful for getting previous return values of custom events.  </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="event.which">
         <desc> For key or button events, this attribute indicates the specific button or key that was pressed.  </desc>
         <signature/>
         <longdesc> 
            <p>
               <code>event.which</code> normalizes <code>event.keyCode</code> and <code>event.charCode</code>. It is recommended to watch <code>event.which</code> for keyboard key input. For more detail, read about <a href="https://developer.mozilla.org/en/DOM/event.charCode#Notes">event.charCode on the MDC</a>. </p> 
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="event.pageY">
         <desc>The mouse position relative to the top edge of the document. </desc>
         <signature/>
         <longdesc>   </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="event.pageX">
         <desc>The mouse position relative to the left edge of the document. </desc>
         <signature/>
         <longdesc>   </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="event.currentTarget">
         <desc> The current DOM element within the event bubbling phase.  </desc>
         <signature/>
         <longdesc>
            <p>This property will always be equal to the <code>this</code> of the function.</p>  
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="event.relatedTarget">
         <desc>  The other DOM element involved in the event, if any. </desc>
         <signature/>
         <longdesc>
            <p>For <code>mouseout</code>, indicates the element being entered; for <code>mousein</code>, indicates the element being exited. </p> 
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="event.data">
         <desc> Contains the optional data passed to jQuery.fn.bind when the current executing handler was bound.  </desc>
         <signature/>
         <longdesc>   </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="event.target">
         <desc> The DOM element that initiated the event.  </desc>
         <signature/>
         <longdesc> 
            <p>This can be the element that registered for the event or a child of it.  It is often useful to compare <code>event.target</code> to <code>this</code> in order to determine if the event is being handled due to event bubbling. This property is very useful in event delegation, when events bubble.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="event.type">
         <desc> Describes the nature of the event.  </desc>
         <signature/>
         <longdesc>   </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="jQuery.fx.off">
         <desc>关闭页面上所有的动画。</desc>
         <signature/>
         <longdesc>把这个属性设置为true可以立即关闭所有动画(所有效果会立即执行完毕)。有些情况下可能需要这样，比如：

* 你在配置比较低的电脑上使用jQuery。

* 你的一些用户由于动画效果而遇到了 &lt;a href="http://www.jdeegan.phlegethon.org/turn_off_animation.html"&gt;可访问性问题&lt;/a&gt;

当把这个属性设成false之后，可以重新开启所有动画。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="each">
         <desc>以每一个匹配的元素作为上下文来执行一个函数。</desc>
         <signature>
            <argument name="function(index, Element)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>意味着，每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素（每次都是一个不同的匹配元素）。而且，在每次执行函数时，都会给函数传递一个表示作为执行环境的元素在匹配的元素集合中所处位置的数字值作为参数（从零开始的整型）。 返回 'false' 将停止循环 (就像在普通的循环中使用 'break')。返回 'true' 跳至下一个循环(就像在普通的循环中使用'continue')。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="pushStack">
         <desc>Add a collection of DOM elements onto the jQuery stack.</desc>
         <signature>
            <argument name="elements">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="elements">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="name">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="arguments">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.globalEval">
         <desc>Execute some JavaScript code globally.</desc>
         <signature>
            <argument name="code">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>This method behaves differently from using a normal JavaScript <code>eval()</code> in that it's executed within the global context (which is important for loading external scripts dynamically).</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.isXMLDoc">
         <desc>Check to see if a DOM node is within an XML document (or is an XML document).</desc>
         <signature>
            <argument name="node">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.removeData">
         <desc>Remove a previously-stored piece of data.</desc>
         <signature>
            <argument name="element">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="name">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>Note:</strong> This is a low-level method, you should probably use <code>
                  <a href="/removeData">.removeData()</a>
               </code> instead.</p>
	           <p>The <code>jQuery.removeData()</code> method allows us to remove values that were previously set using <code>
                  <a href="/jQuery.data">jQuery.data()</a>
               </code>. When called with the name of a key, <code>jQuery.removeData()</code> deletes that particular value; when called with no arguments, all values are removed.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.data">
         <desc>在元素上存放数据,返回jQuery对象。 查询在元素上存放的数据</desc>
         <signature>
            <argument name="element">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="key">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>注意：这是一个底层方法。你应当使用.data()来代替。如果不指定参数，则会返回元素上面存放的所有数据，以Object的形式返回。
		
注意：这是一个底层方法。你应当使用.data()来代替。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.data">
         <desc>在元素上存放数据,返回jQuery对象。 查询在元素上存放的数据</desc>
         <signature>
            <argument name="element">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="key">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="element">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>注意：这是一个底层方法。你应当使用.data()来代替。如果不指定参数，则会返回元素上面存放的所有数据，以Object的形式返回。
		
注意：这是一个底层方法。你应当使用.data()来代替。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.dequeue">
         <desc>Execute the next function on the queue for the matched element.</desc>
         <signature>
            <argument name="element">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="queueName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>Note:</strong> This is a low-level method, you should probably use <code>
                  <a href="/dequeue">.dequeue()</a>
               </code> instead.</p>
            <p>When <code>jQuery.dequeue()</code> is called, the next function on the queue is removed from the queue, and then executed. This function should in turn (directly or indirectly) cause <code>jQuery.dequeue()</code> to be called, so that the sequence can continue.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.queue">
         <desc>Show the queue of functions to be executed on the matched element.</desc>
         <signature>
            <argument name="element">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="queueName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>Note:</strong> This is a low-level method, you should probably use <code>
                  <a href="/queue">.queue()</a>
               </code> instead.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.queue">
         <desc>Manipulate the queue of functions to be executed on the matched element.</desc>
         <signature>
            <argument name="element">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="queueName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="newQueue">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="element">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="queueName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback()">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>Note:</strong> This is a low-level method, you should probably use <code>
                  <a href="/queue">.queue()</a>
               </code> instead.</p>
	           <p>Every element can have one or more queues of functions attached to it by jQuery. In most applications, only one queue (called <code>fx</code>) is used. Queues allow a sequence of actions to be called on an element asynchronously, without halting program execution.</p>
	           <p>The <code>jQuery.queue()</code> method allows us to directly manipulate this queue of functions. Calling <code>jQuery.queue()</code> with a callback is particularly useful; it allows us to place a new function at the end of the queue.</p>
	           <p>Note that when adding a function with <code>jQuery.queue()</code>, we should ensure that <code>jQuery.dequeue()</code> is eventually called so that the next function in line executes.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="clearQueue">
         <desc>jQuery 1.4 新增。清空对象上尚未执行的所有队列</desc>
         <signature>
            <argument name="queueName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果不带参数，则默认清空的是动画队列。这跟stop(true)类似，但stop()只能清空动画队列，而这个可以清空所有通过 .queue() 创建的队列。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="toArray">
         <desc>Retrieve all the DOM elements contained in the jQuery set, as an array.</desc>
         <signature/>
         <longdesc>
            <p>
               <code>.toArray()</code> returns all of the elements in the jQuery set:</p>
            <pre>alert($('li').toArray());</pre>
            <p>All of the matched DOM nodes are returned by this call, contained in a standard array:</p>
            <p>
               <span class="result">[&lt;li id="foo"&gt;, &lt;li id="bar"&gt;]</span>
            </p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.isEmptyObject">
         <desc>jQuery 1.4 新增。测试对象是否是空对象（不包含任何属性）。</desc>
         <signature>
            <argument name="object">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>jQuery 1.4 中，这个方法既检测对象本身的属性，也检测从原型继承的属性（因此没有使用hasOwnProperty）。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.isPlainObject">
         <desc>jQuery 1.4 新增。测试对象是否是纯粹的对象（通过 "{}" 或者 "new Object" 创建的）。</desc>
         <signature>
            <argument name="object">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="keydown">
         <desc>触发每一个匹配元素的keydown事件 在每一个匹配元素的keydown事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>这个函数会调用执行绑定到keydown事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。keydown事件会在键盘按下时触发。keydown事件会在键盘按下时触发。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="index">
         <desc>搜索匹配的元素，并返回相应元素的索引值，从0开始计数。</desc>
         <signature/>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="element">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果不给 .index() 方法传递参数，那么返回值就是这个jQuery对象集合中第一个元素相对于其同辈元素的位置。
		
			如果参数是一组DOM元素或者jQuery对象，那么返回值就是传递的元素相对于原先集合的位置。
		
		如果参数是一个选择器，那么返回值就是原先元素相对于选择器匹配元素中的位置。如果找不到匹配的元素，则返回-1。
		
		具体请参考示例。
		</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="removeData">
         <desc>在元素上移除存放的数据</desc>
         <signature>
            <argument name="name">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>与$(...).data(name, value)函数作用相反</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="data">
         <desc>返回元素上储存的相应名字的数据，可以用data(name, value)来设定。 在元素上存放数据,返回jQuery对象。 在元素上存放一组数据，返回jQuery对象。</desc>
         <signature>
            <argument name="key">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="obj">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果jQuery集合指向多个元素，那将只返回第一个元素的对应数据。

这个函数可以用于在一个元素上存取数据而避免了循环引用的风险。jQuery.data是1.2.3版的新功能。你可以在很多地方使用这个函数，另外jQuery UI里经常使用这个函数。

如果不带任何参数，则会把所有数据作为一个JavaScript对象来返回。如果jQuery集合指向多个元素，那将在所有元素上设置对应数据。

这个函数不用建立一个新的expando，就能在一个元素上存放任何格式的数据，而不仅仅是字符串。注意，如果使用这个方法之后，原先存放的所有数据都会被重写！因为这些数据，包括事件处理函数，都是绑定在元素上的。所以以一个obj作为参数使用 .data()方法时，请务必小心！</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="data">
         <desc>返回元素上储存的相应名字的数据，可以用data(name, value)来设定。 在元素上存放数据,返回jQuery对象。 在元素上存放一组数据，返回jQuery对象。</desc>
         <signature>
            <argument name="key">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>如果jQuery集合指向多个元素，那将只返回第一个元素的对应数据。

这个函数可以用于在一个元素上存取数据而避免了循环引用的风险。jQuery.data是1.2.3版的新功能。你可以在很多地方使用这个函数，另外jQuery UI里经常使用这个函数。

如果不带任何参数，则会把所有数据作为一个JavaScript对象来返回。如果jQuery集合指向多个元素，那将在所有元素上设置对应数据。

这个函数不用建立一个新的expando，就能在一个元素上存放任何格式的数据，而不仅仅是字符串。注意，如果使用这个方法之后，原先存放的所有数据都会被重写！因为这些数据，包括事件处理函数，都是绑定在元素上的。所以以一个obj作为参数使用 .data()方法时，请务必小心！</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="get">
         <desc>取得所有匹配的 DOM 元素集合。 取得其中一个匹配的元素。 num表示取得第几个匹配的元素。</desc>
         <signature>
            <argument name="index">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这是取得所有匹配元素的一种向后兼容的方式（不同于jQuery对象，而实际上是元素数组）。

如果你想要直接操作 DOM 对象而不是 jQuery 对象，这个函数非常有用。这能够让你选择一个实际的DOM 元素并且对他直接操作，而不是通过 jQuery 函数。$(this).get(0)与$(this)[0]等价。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="size">
         <desc>jQuery 对象中元素的个数。</desc>
         <signature/>
         <longdesc>这个函数的返回值与 jQuery 对象的'&lt;span title="Core/length"&gt;length&lt;/span&gt;' 属性一致。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.noConflict">
         <desc>运行这个函数将变量$的控制权让渡给第一个实现它的那个库。 将$和jQuery的控制权都交还给原来的库。用之前请考虑清楚!</desc>
         <signature>
            <argument name="removeAll">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这有助于确保jQuery不会与其他库的$对象发生冲突。

在运行这个函数后，就只能使用jQuery变量访问jQuery对象。例如，在要用到$("div p")的地方，就必须换成jQuery("div p")。

'''注意:'''这个函数必须在你导入jQuery文件之后，并且在导入另一个导致冲突的库'''之前'''使用。当然也应当在其他冲突的库被使用之前，除非jQuery是最后一个导入的。这是相对于简单的 '''noConflict''' 方法更极端的版本，因为这将完全重新定义jQuery。这通常用于一种极端的情况，比如你想要将jQuery嵌入一个高度冲突的环境。'''注意:'''调用此方法后极有可能导致插件失效。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="selected">
         <desc>匹配所有选中的option元素</desc>
         <signature/>
         <longdesc>
            <p>The <code>:selected</code> selector works for <code>&lt;option&gt;</code> elements. It does not work for checkboxes or radio inputs; use <code>:checked</code> for them.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="checked">
         <desc>匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option)</desc>
         <signature/>
         <longdesc>
            <p>The <code>:checked</code> selector works for checkboxes and radio buttons. For select elements, use the <code>:selected</code> selector.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="disabled">
         <desc>匹配所有不可用元素</desc>
         <signature/>
         <longdesc>
            <p>As with other pseudo-class selectors (those that begin with a ":") it is recommended to precede it with a tag name or some other selector; otherwise, the universal selector ("*") is implied. In other words, the bare <code>$(':disabled')</code> is equivalent to <code>$('*:disabled')</code>, so <code>$('input:disabled')</code> should be used instead. </p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="enabled">
         <desc>匹配所有可用元素</desc>
         <signature/>
         <longdesc>
            <p>As with other pseudo-class selectors (those that begin with a ":") it is recommended to precede it with a tag name or some other selector; otherwise, the universal selector ("*") is implied. In other words, the bare <code>$(':enabled')</code> is equivalent to <code>$('*:enabled')</code>, so <code>$('input:enabled')</code> should be used instead. </p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="file">
         <desc>匹配所有文件域</desc>
         <signature/>
         <longdesc>
            <p>As with other pseudo-class selectors (those that begin with a ":") it is recommended to precede it with a tag name or some other selector; otherwise, the universal selector ("*") is implied. In other words, the bare <code>$(':file')</code> is equivalent to <code>$('*:file')</code>, so <code>$('input:file')</code> should be used instead. </p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="button">
         <desc>匹配所有按钮</desc>
         <signature/>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="reset">
         <desc>匹配所有重置按钮</desc>
         <signature/>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="image">
         <desc>匹配所有图像域</desc>
         <signature/>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="submit">
         <desc>匹配所有提交按钮</desc>
         <signature/>
         <longdesc>
            <p>The <code>:submit</code> selector typically applies to button or input elements. Note that some browsers treat <code>&lt;button&gt;</code> element as <code>type="default"</code> implicitly while others (such as Internet Explorer) do not.  </p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="checkbox">
         <desc>匹配所有复选框</desc>
         <signature/>
         <longdesc>
            <p>
               <code>$(':checkbox')</code> is equivalent to <code>$('[type=checkbox]')</code>. As with other pseudo-class selectors (those that begin with a ":") it is recommended to precede it with a tag name or some other selector; otherwise, the universal selector ("*") is implied. In other words, the bare <code>$(':checkbox')</code> is equivalent to <code>$('*:checkbox')</code>, so <code>$('input:checkbox')</code> should be used instead. </p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="radio">
         <desc>匹配所有单选按钮</desc>
         <signature/>
         <longdesc>
            <p>
               <code>$(':radio')</code> is equivalent to <code>$('[type=radio]')</code>. As with other pseudo-class selectors (those that begin with a ":") it is recommended to precede it with a tag name or some other selector; otherwise, the universal selector ("*") is implied. In other words, the bare <code>$(':radio')</code> is equivalent to <code>$('*:radio')</code>, so <code>$('input:radio')</code> should be used instead. </p>
            <p>To select a set of associated radio buttons, you might use: <code>$('input[name=gender]:radio')</code>
            </p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="password">
         <desc>匹配所有密码框</desc>
         <signature/>
         <longdesc>
            <p>
               <code>$(':password')</code> is equivalent to <code>$('[type=password]')</code>. As with other pseudo-class selectors (those that begin with a ":") it is recommended to precede it with a tag name or some other selector; otherwise, the universal selector ("*") is implied. In other words, the bare <code>$(':password')</code> is equivalent to <code>$('*:password')</code>, so <code>$('input:password')</code> should be used instead. </p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="text">
         <desc>匹配所有的单行文本框</desc>
         <signature/>
         <longdesc>
            <p>
               <code>$(':text')</code> is equivalent to <code>$('[type=text]')</code> and thus selects all <code>&lt;input type="text"&gt;</code> elements. As with other pseudo-class selectors (those that begin with a ":") it is recommended to precede it with a tag name or some other selector; otherwise, the universal selector ("*") is implied. In other words, the bare <code>$(':text')</code> is equivalent to <code>$('*:text')</code>, so <code>$('input:text')</code> should be used instead. </p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="input">
         <desc>匹配所有 input, textarea, select 和 button 元素</desc>
         <signature/>
         <longdesc>
            <p>The <code>:input</code> selector basically selects all form controls.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="only-child">
         <desc>Selects all elements that are the only child of their parent.</desc>
         <signature/>
         <longdesc>
            <p>If the parent has other child elements, nothing is matched.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="last-child">
         <desc>Selects all elements that are the last child of their parent.</desc>
         <signature/>
         <longdesc>
            <p>While <a href="/last-selector">:last</a> matches only a single element, <code>:last-child</code> can match more than one: one for each parent.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="first-child">
         <desc>Selects all elements that are the first child of their parent.</desc>
         <signature/>
         <longdesc>
            <p>While <a href="/first-selector">:first</a> matches only a single element, the <code>:first-child</code> selector can match more than one: one for each parent. This is equivalent to <code>:nth-child(1)</code>.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="nth-child">
         <desc>Selects all elements that are the nth-child of their parent.</desc>
         <signature>
            <argument name="index">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Because jQuery's implementation of <code>:nth-child(n)</code> is strictly derived from the CSS specification, the value of <code>n</code> is "1-indexed", meaning that the counting starts at 1. For all other selector expressions, however, jQuery follows JavaScript's "0-indexed" counting. Therefore, given a single <code>&lt;ul&gt;</code> containing two <code>&lt;li&gt;</code>s, <code>$('li:nth-child(1)')</code> selects the first <code>&lt;li&gt;</code> while  <code>$('li:eq(1)')</code> selects the second.</p>
                
            <p>The <code>:nth-child(n)</code> pseudo-class is easily confused with <code>:eq(n)</code>, even though the two can result in dramatically different matched elements. With <code>:nth-child(n)</code>, all children are counted, regardless of what they are, and the specified element is selected only if it matches the selector attached to the pseudo-class. With <code>:eq(n)</code> only the selector attached to the pseudo-class is counted, not limited to children of any other element, and the (n+1)th one (n is 0-based) is selected.</p> 

            <p>Further discussion of this unusual usage can be found in the <a href="http://www.w3.org/TR/css3-selectors/#nth-child-pseudo">W3C CSS specification</a>.</p>
                    </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="attributeContainsPrefix">
         <desc>Selects elements that have the specified attribute with a value either equal to a given string or starting with that string followed by a hyphen (-).</desc>
         <signature>
            <argument name="attribute">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>This selector was introduced into the CSS specification to handle language attributes.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="attributeContainsWord">
         <desc>Selects elements that have the specified attribute with a value containing a given word, delimited by spaces.</desc>
         <signature>
            <argument name="attribute">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>This selector matches the test string against each word in the attribute value, where a "word" is defined as a string delimited by whitespace. The selector matches if the test string is exactly equal to any of the words.</p> 
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="attributeMultiple">
         <desc>复合属性选择器，需要同时满足多个条件时使用。</desc>
         <signature>
            <argument name="attributeFilter1">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="attributeFilter2">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="attributeFilterN">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="attributeContains">
         <desc>匹配给定的属性是以包含某些值的元素</desc>
         <signature>
            <argument name="attribute">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>This is the most generous of the jQuery attribute selectors that match against a value. It will select an element if the selector's string appears anywhere within the element's attribute value. Compare this selector with the Attribute Contains Word selector (e.g. [attr~=word]), which is more appropriate in many cases.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="attributeEndsWith">
         <desc>匹配给定的属性是以某些值结尾的元素</desc>
         <signature>
            <argument name="attribute">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="attributeStartsWith">
         <desc>匹配给定的属性是以某些值开始的元素</desc>
         <signature>
            <argument name="attribute">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>This selector can be useful for identifying elements in pages produced by server-side frameworks that produce HTML with systematic element IDs. However it will be slower than using a class selector so leverage classes, if you can, to group like elements.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="attributeNotEqual">
         <desc>匹配所有不含有指定的属性，或者属性不等于特定值的元素。</desc>
         <signature>
            <argument name="attribute">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>此选择器等价于:not([attr=value])&lt;br&gt;要匹配含有特定属性但不等于特定值的元素，请使用[attr]:not([attr=value])</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="attributeEquals">
         <desc>匹配给定的属性是某个特定值的元素</desc>
         <signature>
            <argument name="attribute">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="attributeHas">
         <desc>匹配包含给定属性的元素。注意，在jQuery 1.3中，前导的@符号已经被废除！如果想要兼容最新版本，只需要简单去掉@符号即可。</desc>
         <signature>
            <argument name="attribute">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="visible">
         <desc>匹配所有的可见元素</desc>
         <signature/>
         <longdesc> 
            <p>Elements can be considered hidden for several reasons:</p>
            <ul>
               <li>They have a CSS <code>display</code> value of <code>none</code>.</li>
               <li>They are form elements with <code>type="hidden"</code>.</li>
               <li>Their width and height are explicitly set to 0.</li>
               <li>An ancestor element is hidden, so the element is not shown on the page.</li>
            </ul>
            <p>Elements with <code>visibility: hidden</code> or <code>opacity: 0</code> are considered to be visible, since they still consume space in the layout. During animations that hide an element, the element is considered to be visible until the end of the animation. During animations to show an element, the element is considered to be visible at the start at the animation.</p>
            <p>How <code>:visible</code> is calculated was changed in jQuery 1.3.2. The <a href="http://docs.jquery.com/Release:jQuery_1.3.2#:visible.2F:hidden_Overhauled">release notes</a> outline the changes in more detail.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="hidden">
         <desc>匹配所有的不可见元素，input 元素的 type 属性为 "hidden" 的话也会被匹配到 匹配所有不可见元素，或者type为hidden的元素</desc>
         <signature/>
         <longdesc>
                    <p>Elements can be considered hidden for several reasons:</p>
            <ul>
               <li>They have a CSS <code>display</code> value of <code>none</code>.</li>
               <li>They are form elements with <code>type="hidden"</code>.</li>
               <li>Their width and height are explicitly set to 0.</li>
               <li>An ancestor element is hidden, so the element is not shown on the page.</li>
            </ul>
            <p>Elements with <code>visibility: hidden</code> or <code>opacity: 0</code> are considered to be visible, since they still consume space in the layout. During animations that hide an element, the element is considered to be visible until the end of the animation. During animations to show an element, the element is considered to be visible at the start at the animation.</p>
            <p>How <code>:hidden</code> is determined was changed in jQuery 1.3.2. An element is assumed to be hidden if it or any of its parents consumes no space in the document. CSS visibility isn't taken into account (therefore <code>$(elem).css('visibility','hidden').is(':hidden') == false</code>). The <a href="http://docs.jquery.com/Release:jQuery_1.3.2#:visible.2F:hidden_Overhauled">release notes</a> outline the changes in more detail.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="parent">
         <desc>匹配含有子元素或者文本的元素</desc>
         <signature/>
         <longdesc>
            <p>This is the inverse of <code>:empty</code>. </p>
            <p>One important thing to note regarding the use of <code>:parent</code> (and <code>:empty</code>) is that child elements include text nodes.</p>
            <p>The W3C recommends that the <code>&lt;p&gt;</code> element have at least one child node, even if that child is merely text (see <a href="http://www.w3.org/TR/html401/struct/text.html#edef-P">http://www.w3.org/TR/html401/struct/text.html#edef-P</a>). Some other elements, on the other hand, are empty (i.e. have no children) by definition:<code> &lt;input&gt;</code>, <code>&lt;img&gt;</code>, <code>&lt;br&gt;</code>, and <code>&lt;hr&gt;</code>, for example.</p>
    
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="has">
         <desc>匹配含有选择器所匹配的元素的元素</desc>
         <signature/>
         <longdesc>
            <p>The expression <code>$('div:has(p)')</code> matches a <code>&lt;div&gt;</code> if a <code>&lt;p&gt;</code> exists anywhere among its descendants, not just as a direct child.</p> 
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="empty">
         <desc>匹配所有不包含子元素或者文本的空元素</desc>
         <signature/>
         <longdesc>
            <p>This is the inverse of <code>:parent</code>. </p>
            <p>One important thing to note with :empty (and :parent) is that child elements include text nodes.</p>
            <p>The W3C recommends that the <code>&lt;p&gt;</code> element have at least one child node, even if that child is merely text (see http://www.w3.org/TR/html401/struct/text.html#edef-P). Some other elements, on the other hand, are empty (i.e. have no children) by definition: &lt;input&gt;, &lt;img&gt;, &lt;br&gt;, and &lt;hr&gt;, for example.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="contains">
         <desc>匹配包含给定文本的元素</desc>
         <signature/>
         <longdesc>
            <p>The matching text can appear directly within the selected element, in any of that element's descendants, or a combination thereof. As with attribute value selectors, text inside the parentheses of <code>:contains()</code> can be written as bare words or surrounded by quotation marks. The text must have matching case to be selected.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="animated">
         <desc>匹配所有正在执行动画效果的元素</desc>
         <signature/>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="header">
         <desc>匹配如 h1, h2, h3之类的标题元素</desc>
         <signature/>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="lt">
         <desc>匹配所有小于给定索引值的元素</desc>
         <signature>
            <argument name="index">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <strong>index-related selectors</strong>
            </p>
            <p>The index-related selectors (including this "less than" selector) filter the set of elements that have matched the expressions that precede them. They narrow the set down based on the order of the elements within this matched set. For example, if elements are first selected with a class selector (<code>.myclass</code>) and four elements are returned, these elements are given indices 0 through 3 for the purposes of these selectors.</p>
            <p>Note that since JavaScript arrays use <em>0-based indexing</em>, these selectors reflect that fact. This is why <code>$('.myclass:lt(1)')</code> selects the first element in the document with the class <code>myclass</code>, rather than selecting no elements. In contrast, <code>:nth-child(n)</code> uses <em>1-based indexing</em> to conform to the CSS specification.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="gt">
         <desc>匹配所有大于给定索引值的元素</desc>
         <signature/>
         <longdesc>
            <p>
               <strong>index-related selectors</strong>
            </p>
                  <p>The index-related selector expressions (including this "greater than" selector) filter the set of elements that have matched the expressions that precede them. They narrow the set down based on the order of the elements within this matched set. For example, if elements are first selected with a class selector (<code>.myclass</code>) and four elements are returned, these elements are given indices 0 through 3 for the purposes of these selectors.</p>
                <p>Note that since JavaScript arrays use <em>0-based indexing</em>, these selectors reflect that fact. This is why <code>$('.myclass:gt(1)')</code> selects elements after the second element in the document with the class <code>myclass</code>, rather than after the first. In contrast, <code>:nth-child(n)</code> uses <em>1-based indexing</em> to conform to the CSS specification.</p>
                </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="eq">
         <desc>匹配一个给定索引值的元素</desc>
         <signature>
            <argument name="index">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>The index-related selectors (<code>:eq()</code>, <code>:lt()</code>, <code>:gt()</code>, <code>:even</code>, <code>:odd</code>) filter the set of elements that have matched the expressions that precede them. They narrow the set down based on the order of the elements within this matched set. For example, if elements are first selected with a class selector (<code>.myclass</code>) and four elements are returned, these elements are given indices <code>0</code> through <code>3</code> for the purposes of these selectors.</p>
            <p>Note that since JavaScript arrays use <em>0-based indexing</em>, these selectors reflect that fact. This is why <code>$('.myclass:eq(1)')</code> selects the second element in the document with the class myclass, rather than the first. In contrast, <code>:nth-child(n)</code> uses <em>1-based indexing</em> to conform to the CSS specification.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="odd">
         <desc>匹配所有索引值为奇数的元素，从 0 开始计数</desc>
         <signature/>
         <longdesc>
            <p>In particular, note that the <em>0-based indexing</em> means that, counter-intuitively, <code>:odd</code> selects the second element, fourth element, and so on within the matched set.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="even">
         <desc>匹配所有索引值为偶数的元素，从 0 开始计数</desc>
         <signature/>
         <longdesc>
            <p>In particular, note that the <em>0-based indexing</em> means that, counter-intuitively, <code>:even</code> selects the first element, third element, and so on within the matched set.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="not">
         <desc>去除所有与给定选择器匹配的元素</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>在jQuery 1.3中，已经支持复杂选择器了（例如:not(div a) 和 :not(div,a)）</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="last">
         <desc>匹配找到的最后一个元素</desc>
         <signature/>
         <longdesc>
            <p>Note that <code>:last</code> selects a single element by filtering  the current jQuery collection and matching the last element within it.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="first">
         <desc>匹配找到的第一个元素</desc>
         <signature/>
         <longdesc>
            <p>The <code>:first</code> pseudo-class is equivalent to <code>:eq(0)</code>. It could also be written as <code>:lt(1)</code>. While this matches only a single element, <a href="first-child-selector">:first-child</a> can match more than one: One for each parent.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="next siblings">
         <desc>Selects all sibling elements that follow after the "prev" element, have the same parent, and match the filtering "siblings" selector.</desc>
         <signature>
            <argument name="prev">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="siblings">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>The notable difference between (<code>prev + next</code>) and (<code>prev ~ siblings</code>) is their respective reach. While the former reaches only to the immediately following sibling element, the latter extends that reach to all following sibling elements.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="next adjacent">
         <desc>Selects all next elements matching "next" that are immediately preceded by a sibling "prev".</desc>
         <signature>
            <argument name="prev">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="next">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>One important point to consider with both the next adjacent sibling selector (<code>prev + next</code>) and the general sibling selector (<code>prev ~ siblings</code>) is that the elements on either side of the combinator must share the same parent.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="child">
         <desc>在给定的父元素下匹配所有的子元素</desc>
         <signature>
            <argument name="parent">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="child">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>As a CSS selector, the child combinator is supported by all modern web browsers including Safari, Firefox, Opera, Chrome, and Internet Explorer 7 and above, but notably not by Internet Explorer versions 6 and below. However, in jQuery, this selector (along with all others) works across all supported browsers, including IE6.</p>
            <p>The child combinator (E <strong>&gt;</strong> F) can be thought of as a more specific form of the descendant combinator (E F) in that it selects only first-level descendants.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="descendant">
         <desc>在给定的祖先元素下匹配所有的后代元素</desc>
         <signature>
            <argument name="ancestor">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="descendant">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>A descendant of an element could be a child, grandchild, great-grandchild, and so on, of that element.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="multiple">
         <desc>将每一个选择器匹配到的元素合并后一起返回。</desc>
         <signature>
            <argument name="selector1">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="selector2">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="selectorN">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>你可以指定任意多个选择器，并将匹配到的元素合并到一个结果内。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="all">
         <desc>匹配所有元素</desc>
         <signature/>
         <longdesc>多用于结合上下文来搜索。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="class">
         <desc>根据给定的类匹配元素。</desc>
         <signature>
            <argument name="class">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>For class selectors, jQuery uses JavaScript's native <code>getElementsByClassName()</code> function if the browser supports it.</p>
                
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="element">
         <desc>根据给定的元素名匹配所有元素</desc>
         <signature>
            <argument name="element">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>JavaScript's <code>getElementsByTagName()</code> function is called to return the appropriate elements when this expression is used.</p> 
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="selector" name="id">
         <desc>根据给定的ID匹配一个元素。</desc>
         <signature>
            <argument name="id">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果选择器中包含特殊字符，可以用两个斜杠转义。参见示例。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="scroll">
         <desc>在每一个匹配元素的scroll事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>当滚动条发生变化时触发</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="resize">
         <desc>在每一个匹配元素的resize事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>当文档窗口改变大小时触发</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="dequeue">
         <desc>从队列最前端移除一个队列函数，并执行他。</desc>
         <signature>
            <argument name="queueName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>When <code>.dequeue()</code> is called, the next function on the queue is removed from the queue, and then executed. This function should in turn (directly or indirectly) cause <code>.dequeue()</code> to be called, so that the sequence can continue.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="queue">
         <desc>返回指向第一个匹配元素的队列(将是一个函数数组) 在匹配的元素的队列最后添加一个函数 将匹配元素的队列用新的一个队列来代替(函数数组).</desc>
         <signature>
            <argument name="queueName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="queue">
         <desc>返回指向第一个匹配元素的队列(将是一个函数数组) 在匹配的元素的队列最后添加一个函数 将匹配元素的队列用新的一个队列来代替(函数数组).</desc>
         <signature>
            <argument name="queueName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="newQueue">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="queueName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback( next )">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Every element can have one to many queues of functions attached to it by jQuery. In most applications, only one queue (called <code>fx</code>) is used. Queues allow a sequence of actions to be called on an element asynchronously, without halting program execution. The typical example of this is calling multiple animation methods on an element. For example:</p>
				        <pre>$('#foo').slideUp().fadeIn();</pre>
				        <p>When this statement is executed, the element begins its sliding animation immediately, but the fading transition is placed on the <code>fx</code> queue to be called only once the sliding transition is complete.</p>
				        <p>The <code>.queue()</code> method allows us to directly manipulate this queue of functions. Calling <code>.queue()</code> with a callback is particularly useful; it allows us to place a new function at the end of the queue.</p>
				        <p>This feature is similar to providing a callback function with an animation method, but does not require the callback to be given at the time the animation is performed.</p>
            <pre>$('#foo').slideUp();
$('#foo').queue(function() {
  alert('Animation complete.');
  $(this).dequeue();
});</pre>
            <p>This is equivalent to:</p>
            <pre>$('#foo').slideUp(function() {
  alert('Animation complete.');
});</pre>
            <p>Note that when adding a function with <code>.queue()</code>, we should ensure that <code>.dequeue()</code> is eventually called so that the next function in line executes.</p>
            <p>In jQuery 1.4 the function that's called is passed in another function, as the first argument, that when called automatically dequeues the next item and keeps the queue moving. You would use it like so:</p>
            <pre>$("#test").queue(function(next) {
    // Do some stuff...
    next();
});</pre>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="keyup">
         <desc>触发每一个匹配元素的keyup事件 在每一个匹配元素的keyup事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>这个函数会调用执行绑定到keyup事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。keyup事件会在按键释放时触发。keyup 事件会在键盘按下时触发。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="keypress">
         <desc>触发每一个匹配元素的keypress事件 在每一个匹配元素的keypress事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>T这个函数会调用执行绑定到keydown事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。keydown事件会在键盘按下时触发keypress事件会在敲击按键时触发。 敲击按键的定义为按下并抬起同一个按键。这几个事件发生的顺序是:keydown

keypress

keyup</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="submit">
         <desc>触发每一个匹配元素的submit事件。 在每一个匹配元素的submit事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>这个函数会调用执行绑定到submit事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。submit事件将会在表单提交时触发</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="select">
         <desc>触发每一个匹配元素的select事件 在每一个匹配元素的select事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>这个函数会调用执行绑定到select事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。当用户在文本框(包括input和textarea)中选中某段文本时会触发select事件。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="change">
         <desc>触发每个匹配元素的change事件 在每一个匹配元素的change事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>这个函数会调用执行绑定到change事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。change事件会在元素失去焦点的时候触发，也会当其值在获得焦点后改变时触发。change事件会在元素失去焦点的时候触发，也会当其值在获得焦点后改变时触发。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="blur">
         <desc>触发每一个匹配元素的blur事件。 在每一个匹配元素的blur事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>这个函数会调用执行绑定到blur事件的所有函数，包括浏览器的默认行为。可以通过返回false来防止触发浏览器的默认行为。blur事件会在元素失去焦点的时候触发，既可以是鼠标行为，也可以是按tab键离开的blur事件会在元素失去焦点的时候触发，既可以是鼠标行为，也可以是按tab键离开的</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="focus">
         <desc>触发每一个匹配元素的focus事件。 在每一个匹配元素的focus事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>这将触发所有绑定的focus函数，注意，某些对象不支持focus方法。focus事件可以通过鼠标点击或者键盘上的TAB导航触发</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="mousemove">
         <desc>在每一个匹配元素的mousemove事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>mousemove 事件通过鼠标在元素上移动来触发。事件处理函数会被传递一个变量——事件对象，其.clientX 和 .clientY 属性代表鼠标的坐标</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="hover">
         <desc>一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法。这是一个自定义的方法，它为频繁使用的任务提供了一种“保持在其中”的状态。</desc>
         <signature>
            <argument name="handlerIn(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="handlerOut(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>当鼠标移动到一个匹配的元素上面时，会触发指定的第一个函数。当鼠标移出这个元素时，会触发指定的第二个函数。而且，会伴随着对鼠标是否仍然处在特定元素中的检测（例如，处在div中的图像），如果是，则会继续保持“悬停”状态，而不触发移出事件（修正了使用mouseout事件的一个常见错误）。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="hover">
         <desc>一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法。这是一个自定义的方法，它为频繁使用的任务提供了一种“保持在其中”的状态。</desc>
         <signature>
            <argument name="handlerInOut(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>当鼠标移动到一个匹配的元素上面时，会触发指定的第一个函数。当鼠标移出这个元素时，会触发指定的第二个函数。而且，会伴随着对鼠标是否仍然处在特定元素中的检测（例如，处在div中的图像），如果是，则会继续保持“悬停”状态，而不触发移出事件（修正了使用mouseout事件的一个常见错误）。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="mouseleave">
         <desc>Bind an event handler to be fired when the mouse leaves an element, or trigger that handler on an element.</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>
            <p>This method is a shortcut for <code>.bind('mouseleave', handler)</code> in the first variation, and <code>.trigger('mouseleave')</code> in the second.</p>
            <p>The <code>mouseleave</code> JavaScript event is proprietary to Internet Explorer. Because of the event's general utility, jQuery simulates this event so that it can be used regardless of browser. This event is sent to an element when the mouse pointer leaves the element. Any HTML element can receive this event.</p>
            <p>For example, consider the HTML:</p>
            <pre>&lt;div id="outer"&gt;
  Outer
  &lt;div id="inner"&gt;
    Inner
  &lt;/div&gt;
&lt;/div&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;
&lt;div id="log"&gt;&lt;/div&gt;</pre> 
            <p class="image">
               <img src="/images/0042_05_09.png" alt=""/>
            </p>
            <p>The event handler can be bound to any element:</p>
            <pre>$('#outer').mouseleave(function() {
  $('#log').append('&lt;div&gt;Handler for .mouseleave() called.&lt;/div&gt;');
});</pre>
            <p>Now when the mouse pointer moves out of the <span class="output">Outer</span> 
               <code>&lt;div&gt;</code>, the message is appended to <code>&lt;div id="log"&gt;</code>. We can also trigger the event when another element is clicked:</p>
            <pre>$('#other').click(function() {
  $('#outer').mouseleave();
});</pre>
            <p>After this code executes, clicks on <span class="output">Trigger the handler</span> will also append the message.</p>
            <p>The <code>mouseleave</code> event differs from <code>mouseout</code> in the way it handles event bubbling. If <code>mouseout</code> were used in this example, then when the mouse pointer moved out of the <span class="output">Inner</span> element, the handler would be triggered. This is usually undesirable behavior. The <code>mouseleave</code> event, on the other hand, only triggers its handler when the mouse leaves the element it is bound to, not a descendant. So in this example, the handler is triggered when the mouse leaves the <span class="output">Outer</span> element, but not the <span class="output">Inner</span> element.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="mouseenter">
         <desc>Bind an event handler to be fired when the mouse enters an element, or trigger that handler on an element.</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>
            <p>This method is a shortcut for <code>.bind('mouseenter', handler)</code> in the first variation, and <code>.trigger('mouseenter')</code> in the second.</p>
            <p>The <code>mouseenter</code> JavaScript event is proprietary to Internet Explorer. Because of the event's general utility, jQuery simulates this event so that it can be used regardless of browser. This event sent to an element when the mouse pointer enters the element. Any HTML element can receive this event.</p>
            <p>For example, consider the HTML:</p>
            <pre>&lt;div id="outer"&gt;
  Outer
  &lt;div id="inner"&gt;
    Inner
  &lt;/div&gt;
&lt;/div&gt;
&lt;div id="other"&gt;
  Trigger the handler
&lt;/div&gt;
&lt;div id="log"&gt;&lt;/div&gt;</pre>
 
            <p class="image">
               <img src="/images/0042_05_08.png" alt=""/>
            </p>
            <p>The event handler can be bound to any element:</p>
            <pre>$('#outer').mouseenter(function() {
  $('#log').append('&lt;div&gt;Handler for .mouseenter() called.&lt;/div&gt;');
});</pre>
            <p>Now when the mouse pointer moves over the <span class="output">Outer</span> 
               <code>&lt;div&gt;</code>, the message is appended to <code>&lt;div id="log"&gt;</code>. We can also trigger the event when another element is clicked:</p>
            <pre>$('#other').click(function() {
  $('#outer').mouseenter();
});</pre>
            <p>After this code executes, clicks on <span class="output">Trigger the handler</span> will also append the message.</p>
            <p>The <code>mouseenter</code> event differs from <code>mouseover</code> in the way it handles event bubbling. If <code>mouseover</code> were used in this example, then when the mouse pointer moved over the <span class="output">Inner</span> element, the handler would be triggered. This is usually undesirable behavior. The <code>mouseenter</code> event, on the other hand, only triggers its handler when the mouse enters the element it is bound to, not a descendant. So in this example, the handler is triggered when the mouse enters the <span class="output">Outer</span> element, but not the <span class="output">Inner</span> element.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="mouseout">
         <desc>在每一个匹配元素的mouseout事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>mouseout事件在鼠标从元素上离开后会触发</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="mouseover">
         <desc>在每一个匹配元素的mouseover事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>mouseover事件会在鼠标移入对象时触发</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="dblclick">
         <desc>触发每一个匹配元素的dblclick事件。 在每一个匹配元素的dblclick事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>这个函数会调用执行绑定到dblclick事件的所有函数，包括浏览器的默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。dblclick事件会在元素的同一点双击时触发。的那个在某个元素上双击的时候就会触发dblclick事件</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="click">
         <desc>触发每一个匹配元素的click事件。 在每一个匹配元素的click事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>这个函数会调用执行绑定到click事件的所有函数。点击事件会在你的指针设备的按钮在元素上单击时触发。单击的定义是在屏幕的同一点触发了mousedown和mouseup.几个事件触发的顺序是：mousedownmouseupclick</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="mouseup">
         <desc>在每一个匹配元素的mouseup事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>mouseup事件会在鼠标点击对象释放时</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="mousedown">
         <desc>在每一个匹配元素的mousedown事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>mousedown事件在鼠标在元素上点击后会触发</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="error">
         <desc>触发每一个匹配元素的error事件。 在每一个匹配元素的error事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个函数会调用所有绑定到error事件上的函数，包括在对应元素上的浏览器默认行为。可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为。error事件通常可以在元素由于点击或者tab导航失去焦点时触发。对于error事件，没有一个公众的标准。在大多数浏览器中，当页面的JavaScript发生错误时，window对象会触发error事件;当图像的src属性无效时，比如文件不存在或者图像数据错误时，也会触发图像对象的error事件。

如果异常是由window对象抛出，事件处理函数将会被传入三个参数：

1. 描述事件的信息 ("varName is not defined", "missing operator in expression", 等等.),

2. 包含错误的文档的完整URL

3. 异常发生的行数 如果事件处理函数返回true，则表示事件已经被处理，浏览器将认为没有异常。

更多相关信息: 

&lt;a href="http://msdn2.microsoft.com/en-us/library/ms536930.aspx"&gt;msdn - onerror Event&lt;/a&gt;

&lt;a href="http://developer.mozilla.org/en/docs/DOM:window.onerror"&gt;Gecko DOM Reference - onerror Event&lt;/a&gt;

&lt;a href="http://developer.mozilla.org/en/docs/DOM:event"&gt;Gecko DOM Reference - Event object&lt;/a&gt;

&lt;a href="http://en.wikipedia.org/wiki/DOM_Events"&gt;Wikipedia: DOM Events&lt;/a&gt;</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="unload">
         <desc>在每一个匹配元素的unload事件中绑定一个处理函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>This method is a shortcut for <code>.bind('unload', handler)</code>.</p>
            <p>The <code>unload</code> event is sent to the <code>window</code> element when the user navigates away from the page. This could mean one of many things. The user could have clicked on a link to leave the page, or typed in a new URL in the address bar. The forward and back buttons will trigger the event. Closing the browser window will cause the event to be triggered. Even a page reload will first create an <code>unload</code> event.</p>
            <blockquote>
               <p>The exact handling of the <code>unload</code> event has varied from version to version of browsers. For example, some versions of Firefox trigger the event when a link is followed, but not when the window is closed. In practical usage, behavior should be tested on all supported browsers, and contrasted with the proprietary <code>beforeunload</code> event.</p>
            </blockquote>
            <p>Any <code>unload</code> event handler should be bound to the <code>window</code> object:</p>
            <pre>$(window).unload(function() {
  alert('Handler for .unload() called.');
});
</pre>
            <p>After this code executes, the alert will be displayed whenever the browser leaves the current page.
It is not possible to cancel the <code>unload</code> event with <code>.preventDefault()</code>. This event is available so that scripts can perform cleanup when the user leaves the page.
</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="load">
         <desc>在每一个匹配元素的load事件中绑定一个处理函数。 载入远程 HTML 文件代码并插入至 DOM 中。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果绑定给window对象，则会在所有内容加载后触发，包括窗口，框架，对象和图像。如果绑定在元素上，则当元素的内容加载完毕后触发。

'''注意:'''只有当在这个元素完全加载完之前绑定load的处理函数,才会在他加载完后触发。如果之后再绑定就永远不会触发了。所以'''不要'''在$(document).ready()里绑定load事件，因为jQuery会在所有DOM加载完成后再绑定load事件。默认使用 GET 方式 - 传递附加参数时自动转换为 POST 方式。jQuery 1.2 中，可以指定选择符，来筛选载入的 HTML 文档，DOM 中将仅插入筛选出的 HTML 代码。语法形如 "url #some &gt; selector"。请查看示例。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="ready">
         <desc>当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。</desc>
         <signature>
            <argument name="handler">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这是事件模块中最重要的一个函数，因为它可以极大地提高web应用程序的响应速度。

简单地说，这个方法纯粹是对向window.load事件注册事件的替代方法。通过使用这个方法，可以在DOM载入就绪能够读取并操纵时立即调用你所绑定的函数，而99.99%的JavaScript函数都需要在那一刻执行。

有一个参数－－对jQuery函数的引用－－会传递到这个ready事件处理函数中。可以给这个参数任意起一个名字，并因此可以不再担心命名冲突而放心地使用$别名。

请确保在 &lt;body&gt; 元素的onload事件中没有注册函数，否则不会触发$(document).ready()事件。

可以在同一个页面中无限次地使用$(document).ready()事件。其中注册的函数会按照（代码中的）先后顺序依次执行。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="die">
         <desc>jQuery 1.3新增。此方法与live正好完全相反。</desc>
         <signature/>
         <longdesc>如果不带参数，则所有绑定的live事件都会被移除。

你可以解除用live注册的自定义事件。

如果提供了type参数，那么会移除对应的live事件。

如果也指定了第二个参数function,则只移出指定的事件处理函数。</longdesc>
      </entry>
      <entry type="method" name="die">
         <desc>jQuery 1.3新增。此方法与live正好完全相反。</desc>
         <signature>
            <argument name="eventType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="handler">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果不带参数，则所有绑定的live事件都会被移除。

你可以解除用live注册的自定义事件。

如果提供了type参数，那么会移除对应的live事件。

如果也指定了第二个参数function,则只移出指定的事件处理函数。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="jQuery.browser">
         <desc>在jQuery 1.3中不建议使用。浏览器内核标识。依据 navigator.userAgent 判断。</desc>
         <signature/>
         <longdesc>可用值:  safari 

 opera 

 msie 

 mozilla  此属性在 DOM 树加载完成前即有效，可用于为特定浏览器设置 ready 事件。 

浏览器对象检测技术与此属性共同使用可提供可靠的浏览器检测支持。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="jQuery.browser.version">
         <desc>在jQuery 1.3中不建议使用。浏览器渲染引擎版本号。</desc>
         <signature/>
         <longdesc>典型结果:  Internet Explorer: 6.0, 7.0 

 Mozilla/Firefox/Flock/Camino: 1.7.12, 1.8.1.3 

 Opera: 9.20 

 Safari/Webkit: 312.8, 418.9</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="live">
         <desc>jQuery 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的也有效。</desc>
         <signature>
            <argument name="eventType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="handler">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="eventType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="eventData">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="handler">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个方法是基本是的 .bind() 方法的一个变体。使用 .bind() 时，选择器匹配的元素会附加一个事件处理函数，而以后再添加的元素则不会有。为此需要再使用一次 .bind() 才行。比如说

&lt;pre&gt;&amp;lt;body&amp;gt;
  &amp;lt;div class="clickme"&amp;gt;Click here&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;

可以给这个元素绑定一个简单的click事件：

&lt;pre&gt;$('.clickme').bind('click', function() {
  alert("Bound handler called.");
});
&lt;/pre&gt;

当点击了元素，就会弹出一个警告框。然后，想象一下这之后有另一个元素添加进来了。

&lt;pre&gt;$('body').append('&amp;lt;div class="clickme"&amp;gt;Another target&amp;lt;/div&amp;gt;');&lt;/pre&gt;

尽管这个新的元素也能够匹配选择器 ".clickme" ，但是由于这个元素是在调用 .bind() 之后添加的，所以点击这个元素不会有任何效果。

.live() 就提供了对应这种情况的方法。如果我们是这样绑定click事件的：

&lt;pre&gt;$('.clickme').live('click', function() {
  alert("Live handler called."); 
});&lt;/pre&gt;

然后再添加一个新元素：

&lt;pre&gt;$('body').append('&amp;lt;div class="clickme"&amp;gt;Another target&amp;lt;/div&amp;gt;');&lt;/pre&gt;

然后再点击新增的元素，他依然能够触发事件处理函数。

'''事件委托'''

.live() 方法能对一个还没有添加进DOM的元素有效，是由于使用了事件委托：绑定在祖先元素上的事件处理函数可以对在后代上触发的事件作出回应。传递给 .live() 的事件处理函数不会绑定在元素上，而是把他作为一个特殊的事件处理函数，绑定在 DOM 树的根节点上。在我们的例子中，当点击新的元素后，会依次发生下列步骤：

  &lt;ol&gt;
    &lt;li&gt;生成一个click事件传递给 &amp;lt;div&amp;gt; 来处理 &lt;/li&gt;
    &lt;li&gt;由于没有事件处理函数直接绑定在 &amp;lt;div&amp;gt; 上，所以事件冒泡到DOM树上&lt;/li&gt;
    &lt;li&gt;事件不断冒泡一直到DOM树的根节点，默认情况下上面绑定了这个特殊的事件处理函数。&lt;/li&gt;
    &lt;li&gt;执行由 .live() 绑定的特殊的 click 事件处理函数。&lt;/li&gt;
    &lt;li&gt;这个事件处理函数首先检测事件对象的 target 来确定是不是需要继续。这个测试是通过检测 $(event.target).closest('.clickme') 能否找到匹配的元素来实现的。&lt;/li&gt;
    &lt;li&gt;如果找到了匹配的元素，那么调用原始的事件处理函数。&lt;/li&gt;
  &lt;/ol&gt;

由于只有在事件发生时才会在上面的第五步里做测试，因此在任何时候添加的元素都能够响应这个事件。

'''附加说明'''

.live() 虽然很有用，但由于其特殊的实现方式，所以不能简单的在任何情况下替换 .bind()。主要的不同有：

&lt;ul&gt;
	&lt;li&gt;在jQuery 1.4中，.live()方法支持自定义事件，也支持所有的 JavaScript 事件。在jQuery 1.4.1中，甚至也支持 focus 和 blue 事件了（映射到更合适，并且可以冒泡的focusin和focusout上）。另外，在jQuery 1.4.1中，也能支持hover（映射到"mouseenter mouseleave"）。然而在jQuery 1.3.x中，只支持支持的JavaScript事件和自定义事件：click, dblclick, keydown, keypress, keyup, mousedown, mousemove, mouseout, mouseover, 和 mouseup.&lt;/li&gt;
	&lt;li&gt;.live() 并不完全支持通过DOM遍历的方法找到的元素。取而代之的是，应当总是在一个选择器后面直接使用 .live() 方法，正如前面例子里提到的。&lt;/li&gt;
	&lt;li&gt;当一个事件处理函数用 .live() 绑定后，要停止执行其他的事件处理函数，那么这个函数必须返回 false。 仅仅调用 .stopPropagation() 无法实现这个目的。&lt;/li&gt;
&lt;/ul&gt;

参考 .bind() 方法可以获得更多关于事件绑定的信息。

在jQuery 1.4.1中，你可以一次绑定多个事件给 .live() ，跟 .bind() 提供的功能类似。

在jQuery 1.4 中，data参数可以用于把附加信息传递给事件处理函数。一个很好的用处是应付由闭包导致的问题。可以参考 .bind() 的讨论来获得更多信息。

</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="triggerHandler">
         <desc>这个特别的方法将会触发指定的事件类型上所有绑定的处理函数。但不会执行浏览器默认动作，也不会产生事件冒泡。</desc>
         <signature>
            <argument name="eventType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="extraParameters">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个方法的行为表现与trigger类似，但有以下三个主要区别： 
		
* 第一，他不会触发浏览器默认事件。

* 第二，只触发jQuery对象集合中第一个元素的事件处理函数。

* 第三，这个方法的返回的是事件处理函数的返回值，而不是据有可链性的jQuery对象。此外，如果最开始的jQuery对象集合为空，则这个方法返回 undefined 。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="trigger">
         <desc>在每一个匹配的元素上触发某类事件。</desc>
         <signature>
            <argument name="eventType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="extraParameters">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个函数也会导致浏览器同名的默认行为的执行。比如，如果用trigger()触发一个'submit'，则同样会导致浏览器提交表单。如果要阻止这种默认行为，应返回false。

你也可以触发由bind()注册的自定义事件而不限于浏览器默认事件。

事件处理函数会收到一个修复的(规范化的)事件对象，但这个对象没有特定浏览器才有的属性，比如keyCode。

jQuery也支持 &lt;a href="http://docs.jquery.com/Namespaced_Events"&gt;命名空间事件&lt;/a&gt;。这允许你触发或者解除绑定一组特定的事件处理函数，而无需一一个指定。你可以在事件类型后面加上感叹号 ! 来只触发那些没有命名空间的事件处理函数。

'''jQuery 1.3中新增：'''

所有触发的事件现在会冒泡到DOM树上了。举例来说，如果你在一个段落p上触发一个事件，他首先会在这个元素上触发，其次到父元素，在到父元素的父元素，直到触发到document对象。这个事件对象有一个 .target 属性指向最开始触发这个事件的元素。你可以用 stopPropagation() 来阻止事件冒泡，或者在事件处理函数中返回false即可。

事件对象构造器现在已经公开，并且你可以自行创建一个事件对象。这个事件对象可以直接传递给trigger所触发的事件处理函数。事件对象的完整属性列表可以在 &lt;a href="http://docs.jquery.com/Events/jQuery.Event"&gt;jQuery.Event&lt;/a&gt; 的文档里找到。

你可以有三种方式指定事件类型：

* 你可以传递字符串型的事件名称(type参数)。

* 你可以使用jQuery.Event对象。可以将数据放进这个对象，并且这个对象可以被触发的事件处理函数获取到。

* 最后，你可以传递一个带有数据的字面量对象。他将被复制到真正的jQuery.Event对象上去。 注意在这种情况下你'''必须'''指定一个 &lt;em&gt;type&lt;/em&gt; 属性。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="ajaxComplete">
         <desc>AJAX 请求完成时执行函数。Ajax 事件。</desc>
         <signature>
            <argument name="handler(event, XMLHttpRequest, ajaxOptions)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>XMLHttpRequest 对象和设置作为参数传递给回调函数。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="one">
         <desc>为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。</desc>
         <signature>
            <argument name="eventType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="eventData">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>在每个对象上，这个事件处理函数只会被执行一次。其他规则与bind()函数相同。这个事件处理函数会接收到一个事件对象，可以通过它来阻止（浏览器）默认的行为。如果既想取消默认的行为，又想阻止事件起泡，这个事件处理函数必须返回false。

多数情况下，可以把事件处理函数定义为匿名函数（见示例一）。在不可能定义匿名函数的情况下，可以传递一个可选的数据对象作为第二个参数（而事件处理函数则作为第三个参数），见示例二。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="serializeArray">
         <desc>序列化表格元素 (类似 '.serialize()' 方法) 返回 JSON 数据结构数据。</desc>
         <signature/>
         <longdesc>'''注意'''，此方法返回的是JSON对象而非JSON字符串。需要使用插件或者第三方库进行字符串化操作。

		返回的JSON对象是由一个对象数组组成的，其中每个对象包含一个或两个名值对——name参数和value参数（如果value不为空的话）。举例来说：
&lt;pre&gt;&lt;code&gt;  [ 
     {name: 'firstname', value: 'Hello'}, 
     {name: 'lastname', value: 'World'},
     {name: 'alias'}, // this one was empty
  ]
&lt;/code&gt;&lt;/pre&gt;
		</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="serialize">
         <desc>序列表表格内容为字符串。</desc>
         <signature/>
         <longdesc>
            <p>The <code>.serialize()</code> method creates a text string in standard URL-encoded notation. It operates on a jQuery object representing a set of form elements. The form elements can be of several types:</p>
				        <pre>&lt;form&gt;
  &lt;div&gt;&lt;input type="text" name="a" value="1" id="a" /&gt;&lt;/div&gt;
  &lt;div&gt;&lt;input type="text" name="b" value="2" id="b" /&gt;&lt;/div&gt;
  &lt;div&gt;&lt;input type="hidden" name="c" value="3" id="c" /&gt;&lt;/div&gt;
  &lt;div&gt;
    &lt;textarea name="d" rows="8" cols="40"&gt;4&lt;/textarea&gt;
  &lt;/div&gt;
  &lt;div&gt;&lt;select name="e"&gt;
    &lt;option value="5" selected="selected"&gt;5&lt;/option&gt;
    &lt;option value="6"&gt;6&lt;/option&gt;
    &lt;option value="7"&gt;7&lt;/option&gt;
  &lt;/select&gt;&lt;/div&gt;
  &lt;div&gt;
    &lt;input type="checkbox" name="f" value="8" id="f" /&gt;
  &lt;/div&gt;
  &lt;div&gt;
    &lt;input type="submit" name="g" value="Submit" id="g" /&gt;
  &lt;/div&gt;
&lt;/form&gt;</pre>
				        <p>The <code>.serialize()</code> method can act on a jQuery object that has selected individual form elements, such as <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, and <code>&lt;select&gt;</code>. However, it is typically easier to select the <code>&lt;form&gt;</code> tag itself for serialization:</p>
				        <pre>$('form').submit(function() {
  alert($(this).serialize());
  return false;
});</pre>
				        <p>This produces a standard-looking query string:</p>
				        <pre>a=1&amp;b=2&amp;c=3&amp;d=4&amp;e=5</pre>
            <p>Note: Only <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2">"successful controls"</a> are serialized to the string. No submit button value is serialized since the form was not submitted using a button. For a form element's value to be included in the serialized string, the element must have a <code>name</code> attribute. Data from file select elements is not serialized.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.ajaxSetup">
         <desc>设置全局 AJAX 默认选项。</desc>
         <signature>
            <argument name="options">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>参数见 '$.ajax' 说明。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="ajaxSuccess">
         <desc>AJAX 请求成功时执行函数。Ajax 事件。</desc>
         <signature>
            <argument name="handler(event, XMLHttpRequest, ajaxOptions)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>XMLHttpRequest 对象和设置作为参数传递给回调函数。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="ajaxStop">
         <desc>AJAX 请求结束时执行函数。Ajax 事件。</desc>
         <signature>
            <argument name="handler()">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Whenever an Ajax request completes, jQuery checks whether there are any other outstanding Ajax requests. If none remain, jQuery triggers the <code>ajaxStop</code> event. Any and all handlers that have been registered with the <code>.ajaxStop()</code> method are executed at this time.</p>
            <p>To observe this method in action, we can set up a basic Ajax load request:</p>
            <pre>&lt;div class="trigger"&gt;Trigger&lt;/div&gt;
&lt;div class="result"&gt;&lt;/div&gt;
&lt;div class="log"&gt;&lt;/div&gt;</pre>
            <p>We can attach our event handler to any element:</p>
            <pre>$('.log').ajaxStop(function() {
  $(this).text('Triggered ajaxStop handler.');
});</pre>
            <p>Now, we can make an Ajax request using any jQuery method:</p>
            <pre>$('.trigger').click(function() {
  $('.result').load('ajax/test.html');
});</pre>
            <p>When the user clicks the button and the Ajax request completes, the log message is displayed.</p>
  	         <p>Because <code>.ajaxStop()</code> is implemented as a method of jQuery object instances, we can use the <code>this</code> keyword as we do here to refer to the selected elements within the callback function.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="ajaxStart">
         <desc>AJAX 请求开始时执行函数。Ajax 事件。</desc>
         <signature>
            <argument name="handler()">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Whenever an Ajax request is about to be sent, jQuery checks whether there are any other outstanding Ajax requests. If none are in progress, jQuery triggers the <code>ajaxStart</code> event. Any and all handlers that have been registered with the <code>.ajaxStart()</code> method are executed at this time.</p>
				        <p>To observe this method in action, we can set up a basic Ajax load request:</p>
				        <pre>&lt;div class="trigger"&gt;Trigger&lt;/div&gt;
&lt;div class="result"&gt;&lt;/div&gt;
&lt;div class="log"&gt;&lt;/div&gt;</pre>
				        <p>We can attach our event handler to any element:</p>
				        <pre>$('.log').ajaxStart(function() {
  $(this).text('Triggered ajaxStart handler.');
});</pre>
				        <p>Now, we can make an Ajax request using any jQuery method:</p>
				        <pre>$('.trigger').click(function() {
  $('.result').load('ajax/test.html');
});</pre>
				        <p>When the user clicks the button and the Ajax request is sent, the log message is displayed.</p>

				        <p>
               <strong>Note:</strong> Because <code>.ajaxStart()</code> is implemented as a method of jQuery object instances, we can use the <code>this</code> keyword as we do here to refer to the selected elements within the callback function.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="ajaxSend">
         <desc>AJAX 请求发送前执行函数。Ajax 事件。</desc>
         <signature>
            <argument name="handler(event, XMLHttpRequest, ajaxOptions)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>XMLHttpRequest 对象和设置作为参数传递给回调函数。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="ajaxError">
         <desc>AJAX 请求发生错误时执行函数。Ajax 事件。</desc>
         <signature>
            <argument name="handler(event, XMLHttpRequest, ajaxOptions, thrownError)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>XMLHttpRequest 对象和设置作为参数传递给回调函数。捕捉到的错误可作为最后一个参数传递。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="unbind">
         <desc>bind()的反向操作，从每一个匹配的元素中删除绑定的事件。</desc>
         <signature>
            <argument name="eventType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="event">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果没有参数，则删除所有绑定的事件。

你可以将你用bind()注册的自定义事件取消绑定。

如果提供了事件类型作为参数，则只删除该类型的绑定事件。

如果把在绑定时传递的处理函数作为第二个参数，则只有这个特定的事件处理函数会被删除。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="bind">
         <desc>为每个匹配元素的特定事件绑定事件处理函数。 为每一个匹配元素一个或多个事件绑定事件处理器函数。</desc>
         <signature>
            <argument name="eventType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="eventData">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="events">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>.bind() 方法是用于往文档上附加行为的主要方式。所有JavaScript事件对象，比如focus, mouseover, 和 resize，都是可以作为type参数传递进来的。
		
jQuery还提供了一些绑定这些标准事件类型的简单方式，比如.click()用于简化.bind('click')。一共有以下这些：blur, focus, focusin, focusout, load, resize, scroll, unload, click, dblclick, mousedown, mouseup, mousemove, mouseover, mouseout, mouseenter, mouseleave, change, select, submit, keydown, keypress, keyup, error 。

任何作为type参数的字符串都是合法的；如果一个字符串不是原生的JavaScript事件名，那么这个事件处理函数会绑定到一个自定义事件上。这些自定义事件绝对不会由浏览器触发，但可以通过使用.trigger()或者.triggerHandler()在其他代码中手动触发。

如果type参数的字符串中包含一个点(.)字符，那么这个事件就看做是有命名空间的了。这个点字符就用来分隔事件和他的命名空间。举例来说，如果执行 .bind('click.name', handler) ，那么字符串中的 click 是事件类型，而字符串 name 就是命名空间。命名空间允许我们取消绑定或者触发一些特定类型的事件，而不用触发别的事件。参考unbind()来获取更多信息。

当一个事件传到一个元素上，所有绑定在上面的针对哪个事件的处理函数都会触发。如果注册了多个事件处理函数，总是按照绑定的顺序依次触发。当所有绑定的事件处理函数执行完毕后，事件继续沿着普通的事件冒泡途径上浮。

.bind()最基本的用法是：

&lt;pre&gt;
$('#foo').bind('click', function() {
  alert('User clicked on "foo."');
});
&lt;/pre&gt;

这个代码能使ID为foo的元素响应click事件。当用户点击元素内部之后，就会弹出一个警告框。

'''多个事件'''

依次可以绑定多个事件类型，每个事件类型用空格分隔：

&lt;pre&gt;
$('#foo').bind('mouseenter mouseleave', function() {
  $(this).toggleClass('entered');
});
&lt;/pre&gt;

这个代码让一个&amp;lt;div id="foo"&amp;gt;元素（初始情况下class没有设置成entered），当鼠标移进去的时候，在class中加上entered，而当鼠标移出这个div的时候，则去除这个class值。

在jQuery 1.4中，我们也可以通过传入一个映射对来一次绑定多个事件处理函数：

&lt;pre&gt;
$('#foo').bind({
  click: function() {
    // do something on click
  },
  mouseenter: function() {
    // do something on mouseenter
  }
});
&lt;/pre&gt;

'''事件处理函数'''

fn这个参数接受一个回调函数，就像先前展示的那样。在这个事件处理函数内部，this指向这个函数绑定的DOM元素。如果要让这个元素变成jQuery对象来使用jQuery的方法，可以把这个对象传入 $() 重新封装。比如说：

&lt;pre&gt;$('#foo').bind('click', function() {
  alert($(this).text());
});
&lt;/pre&gt;

这个代码执行之后，当用户点击了ID为foo的元素内部之后，他的文本内容就会出现在一个警告框中。

'''事件对象'''

fn这个参数的回调函数还可以接受一个参数。当这个函数被调用时，一个JavaScript事件对象会作为一个参数传进来。

这个事件对象通常是没有必要且可以省略的参数，因为当这个事件处理函数绑定的时候就能够明确知道他在触发的时候应该做些什么，通常就已经可以获得充分的信息了。然而在有些时候，在事件初始化的时候需要获取更多关于用户环境的信息。可以参考完整的关于&lt;a href="/category/events/event-object/"&gt;事件对象&lt;/a&gt;的内容（英文）。

在事件处理函数内返回false就等价于执行事件对象上的.preventDefault()和.stopPropagation()。

可以像这样在事件处理函数内使用事件对象：

&lt;pre&gt;$(document).ready(function() {
  $('#foo').bind('click', function(event) {
    alert('The mouse cursor is at ('
      + event.pageX + ', ' + event.pageY + ')');
  });
});
&lt;/pre&gt;

注意，这个参数添加到了一个匿名函数上。这个代码可以让用户在点击ID为foo的元素时，报告鼠标点击时相对于页面的坐标。

'''传递事件数据'''

可选的第二个参数data通常用的很少。如果提供了这个参数，那么我们就能把一些附加信息传递给事件处理函数了。这个参数有个很好的用处，就是处理闭包带来的问题。比如我们有两个事件处理函数要指向同一个内部变量：

&lt;pre&gt;var message = 'Spoon!';
$('#foo').bind('click', function() {
  alert(message);
});
message = 'Not in the face!';
$('#bar').bind('click', function() {
  alert(message);
});
&lt;/pre&gt;

由于这两个函数在他们各自的环境中都有message，所以触发时显示的消息都是 Not in the face! 。变量值被改变了。为了回避这个问题，我们可以把message变量作为data参数传递进去：

&lt;pre&gt;var message = 'Spoon!';
$('#foo').bind('click', {msg: message}, function(event) {
  alert(event.data.msg);
});
message = 'Not in the face!';
$('#bar').bind('click', {msg: message}, function(event) {
  alert(event.data.msg);
});
&lt;/pre&gt;

这时在函数内部不再直接指向这个变量了；取而代之的是按值传递给了data参数，他能保持绑定事件时的值。第一个函数现在会显示Spoon!，而第二个则显示Not in the face!

注意，如果这个对象按引用传递给了函数，那么将会使情况变得极其复杂。

另外，可以参考.trigger()方法来了解如何在事件触发时传递数据，而不是在事件绑定的时候传递数据。

在jQuery 1.4中，不再支持把数据以及事件附加到一个object、embed或者applet元素上面。因为当往Java applet元素上附加数据时，会触发一个严重错误警告。
		</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="first">
         <desc>获取第一个元素</desc>
         <signature/>
         <longdesc>[<p>Given a jQuery object that represents a set of DOM elements, the <code>.first()</code> method constructs a new jQuery object from the first matching element.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2&lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
  &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>We can apply this method to the set of list items:</p>
            <pre>$('li').first().css('background-color', 'red');</pre>
            <p>The result of this call is a red background for the first item.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="last">
         <desc>获取最后个元素</desc>
         <signature/>
         <longdesc>[<p>Given a jQuery object that represents a set of DOM elements, the <code>.last()</code> method constructs a new jQuery object from the last matching element.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2&lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
  &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>We can apply this method to the set of list items:</p>
            <pre>$('li').last().css('background-color', 'red');</pre>
            <p>The result of this call is a red background for the final item.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="slice">
         <desc>选取一个匹配的子集</desc>
         <signature>
            <argument name="start">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="end">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>与原来的slice方法类似</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery">
         <desc>这个函数接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素。 根据提供的原始 HTML 标记字符串，动态创建由 jQuery 对象包装的 DOM 元素。 根据提供的原始 HTML 标记字符串，动态创建由 jQuery 对象包装的 DOM 元素。同时设置一系列的属性、事件等。 将一个或多个DOM元素转化为jQuery对象。 返回一个空的jQuery对象。 $(document).ready()的简写。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="context">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="element">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="elementArray">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="jQuery object">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature/>
         <longdesc>jQuery 的核心功能都是通过这个函数实现的。 jQuery中的一切都基于这个函数，或者说都是在以某种方式使用这个函数。这个函数最基本的用法就是向它传递一个表达式（通常由 CSS 选择器组成），然后根据这个表达式来查找所有匹配的元素。

默认情况下, 如果没有指定context参数，$()将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个 context 中查找。在jQuery 1.3.2以后，其返回的元素顺序等同于在context中出现的先后顺序。

参考文档中 选择器 部分获取更多用于 expression 参数的 CSS 语法的信息。你可以传递一个手写的 HTML 字符串，或者由某些模板引擎或插件创建的字符串，也可以是通过 AJAX 加载过来的字符串。但是在你创建 input 元素的时会有限制，可以参考第二个示例。当然这个字符串可以包含斜杠 (比如一个图像地址)，还有反斜杠。当你创建单个元素时，请使用闭合标签或 XHTML 格式。例如，创建一个 span ，可以用 $("&amp;lt;span/&amp;gt;") 或 $("&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;") ，但不推荐 $("&amp;lt;span&amp;gt;")。在jQuery 中，这个语法等同于$(document.createElement("span")) 。这个函数也可以接收XML文档和Window对象（虽然它们不是DOM元素）作为有效的参数。jQuery 1.4中，如果不提供任何参数，则返回一个空jQuery对象。在先前版本中，这会返回一个包含document节点的对象。允许你绑定一个在DOM文档载入完成后执行的函数。这个函数的作用如同$(document).ready()一样，只不过用这个函数时，需要把页面中所有需要在 DOM 加载完成时执行的$()操作符都包装到其中来。从技术上来说，这个函数是可链接的－－但真正以这种方式链接的情况并不多。

你可以在一个页面中使用任意多个$(document).ready事件。参考 ready(Function) 获取更多 ready 事件的信息。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery">
         <desc>这个函数接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素。 根据提供的原始 HTML 标记字符串，动态创建由 jQuery 对象包装的 DOM 元素。 根据提供的原始 HTML 标记字符串，动态创建由 jQuery 对象包装的 DOM 元素。同时设置一系列的属性、事件等。 将一个或多个DOM元素转化为jQuery对象。 返回一个空的jQuery对象。 $(document).ready()的简写。</desc>
         <signature>
            <argument name="html">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="ownerDocument">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="html">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="props">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>jQuery 的核心功能都是通过这个函数实现的。 jQuery中的一切都基于这个函数，或者说都是在以某种方式使用这个函数。这个函数最基本的用法就是向它传递一个表达式（通常由 CSS 选择器组成），然后根据这个表达式来查找所有匹配的元素。

默认情况下, 如果没有指定context参数，$()将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个 context 中查找。在jQuery 1.3.2以后，其返回的元素顺序等同于在context中出现的先后顺序。

参考文档中 选择器 部分获取更多用于 expression 参数的 CSS 语法的信息。你可以传递一个手写的 HTML 字符串，或者由某些模板引擎或插件创建的字符串，也可以是通过 AJAX 加载过来的字符串。但是在你创建 input 元素的时会有限制，可以参考第二个示例。当然这个字符串可以包含斜杠 (比如一个图像地址)，还有反斜杠。当你创建单个元素时，请使用闭合标签或 XHTML 格式。例如，创建一个 span ，可以用 $("&amp;lt;span/&amp;gt;") 或 $("&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;") ，但不推荐 $("&amp;lt;span&amp;gt;")。在jQuery 中，这个语法等同于$(document.createElement("span")) 。这个函数也可以接收XML文档和Window对象（虽然它们不是DOM元素）作为有效的参数。jQuery 1.4中，如果不提供任何参数，则返回一个空jQuery对象。在先前版本中，这会返回一个包含document节点的对象。允许你绑定一个在DOM文档载入完成后执行的函数。这个函数的作用如同$(document).ready()一样，只不过用这个函数时，需要把页面中所有需要在 DOM 加载完成时执行的$()操作符都包装到其中来。从技术上来说，这个函数是可链接的－－但真正以这种方式链接的情况并不多。

你可以在一个页面中使用任意多个$(document).ready事件。参考 ready(Function) 获取更多 ready 事件的信息。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery">
         <desc>这个函数接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素。 根据提供的原始 HTML 标记字符串，动态创建由 jQuery 对象包装的 DOM 元素。 根据提供的原始 HTML 标记字符串，动态创建由 jQuery 对象包装的 DOM 元素。同时设置一系列的属性、事件等。 将一个或多个DOM元素转化为jQuery对象。 返回一个空的jQuery对象。 $(document).ready()的简写。</desc>
         <signature>
            <argument name="callback">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>jQuery 的核心功能都是通过这个函数实现的。 jQuery中的一切都基于这个函数，或者说都是在以某种方式使用这个函数。这个函数最基本的用法就是向它传递一个表达式（通常由 CSS 选择器组成），然后根据这个表达式来查找所有匹配的元素。

默认情况下, 如果没有指定context参数，$()将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个 context 中查找。在jQuery 1.3.2以后，其返回的元素顺序等同于在context中出现的先后顺序。

参考文档中 选择器 部分获取更多用于 expression 参数的 CSS 语法的信息。你可以传递一个手写的 HTML 字符串，或者由某些模板引擎或插件创建的字符串，也可以是通过 AJAX 加载过来的字符串。但是在你创建 input 元素的时会有限制，可以参考第二个示例。当然这个字符串可以包含斜杠 (比如一个图像地址)，还有反斜杠。当你创建单个元素时，请使用闭合标签或 XHTML 格式。例如，创建一个 span ，可以用 $("&amp;lt;span/&amp;gt;") 或 $("&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;") ，但不推荐 $("&amp;lt;span&amp;gt;")。在jQuery 中，这个语法等同于$(document.createElement("span")) 。这个函数也可以接收XML文档和Window对象（虽然它们不是DOM元素）作为有效的参数。jQuery 1.4中，如果不提供任何参数，则返回一个空jQuery对象。在先前版本中，这会返回一个包含document节点的对象。允许你绑定一个在DOM文档载入完成后执行的函数。这个函数的作用如同$(document).ready()一样，只不过用这个函数时，需要把页面中所有需要在 DOM 加载完成时执行的$()操作符都包装到其中来。从技术上来说，这个函数是可链接的－－但真正以这种方式链接的情况并不多。

你可以在一个页面中使用任意多个$(document).ready事件。参考 ready(Function) 获取更多 ready 事件的信息。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="stop">
         <desc>停止所有在指定元素上正在运行的动画。</desc>
         <signature>
            <argument name="clearQueue">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="jumpToEnd">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果队列中有等待执行的动画(并且clearQueue没有设为true)，他们将被马上执行</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="end">
         <desc>回到最近的一个"破坏性"操作之前。即，将匹配的元素列表变为前一次的状态。</desc>
         <signature/>
         <longdesc>如果之前没有破坏性操作，则返回一个空集。所谓的"破坏性"就是指任何改变所匹配的jQuery元素的操作。这包括在 Traversing 中任何返回一个jQuery对象的函数--'add', 'andSelf', 'children', 'filter', 'find', 'map', 'next', 'nextAll', 'not', 'parent', 'parents', 'prev', 'prevAll', 'siblings' and 'slice'--再加上 Manipulation 中的 'clone'。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="andSelf">
         <desc>加入先前所选的加入当前元素中</desc>
         <signature/>
         <longdesc>对于筛选或查找后的元素，要加入先前所选元素时将会很有用。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="siblings">
         <desc>取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。可以用可选的表达式进行筛选。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.siblings()</code> method allows us to search through the siblings of these elements in the DOM tree and construct a new jQuery object from the matching elements.</p>
            <p>The method optionally accepts a selector expression of the same type that we can pass to the <code>$()</code> function. If the selector is supplied, the elements will be filtered by testing whether they match it.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
   &lt;li&gt;list item 1&lt;/li&gt;
   &lt;li&gt;list item 2&lt;/li&gt;
   &lt;li class="third-item"&gt;list item 3&lt;/li&gt;
   &lt;li&gt;list item 4&lt;/li&gt;
   &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>If we begin at the third item, we can find its siblings:</p>
            <pre>$('li.third-item').siblings().css('background-color', 'red');</pre>
            <p>The result of this call is a red background behind items 1, 2, 4, and 5. Since we do not supply a selector expression, all of the siblings are part of the object. If we had supplied one, only the matching items among these four would be included.</p>
            <p>The original element is not included among the siblings, which is important to remember when we wish to find all elements at a particular level of the DOM tree.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="animate">
         <desc>用于创建自定义动画的函数。 用于创建自定义动画的函数。</desc>
         <signature>
            <argument name="properties">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="duration">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="easing">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="properties">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="options">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个函数的关键在于指定动画形式及结果样式属性对象。这个对象中每个属性都表示一个可以变化的样式属性（如“height”、“top”或“opacity”）。注意：所有指定的属性必须用骆驼形式，比如用marginLeft代替margin-left. 

而每个属性的值表示这个样式属性到多少时动画结束。如果是一个数值，样式属性就会从当前的值渐变到指定的值。如果使用的是“hide”、“show”或“toggle”这样的字符串值，则会为该属性调用默认的动画形式。

在 jQuery 1.2 中，你可以使用 em 和 % 单位。另外，在 jQuery 1.2 中，你可以通过在属性值前面指定 "&lt;em&gt;+=&lt;/em&gt;" 或 "&lt;em&gt;-=&lt;/em&gt;" 来让元素做相对运动。

jQuery 1.3中，如果duration设为0则直接完成动画。而在以前版本中则会执行默认动画。这个函数的关键在于指定动画形式及结果样式属性对象。这个对象中每个属性都表示一个可以变化的样式属性（如“height”、“top”或“opacity”）。注意：所有指定的属性必须用骆驼形式，比如用marginLeft代替margin-left. 

而每个属性的值表示这个样式属性到多少时动画结束。如果是一个数值，样式属性就会从当前的值渐变到指定的值。如果使用的是“hide”、“show”或“toggle”这样的字符串值，则会为该属性调用默认的动画形式。

在 jQuery 1.2 中，你可以使用 em 和 % 单位。另外，在 jQuery 1.2 中，你可以通过在属性值前面指定 "&lt;em&gt;+=&lt;/em&gt;" 或 "&lt;em&gt;-=&lt;/em&gt;" 来让元素做相对运动。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="prevAll">
         <desc>查找当前元素之前所有的同辈元素</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>可以用表达式过滤。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="prev">
         <desc>取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>可以用一个可选的表达式进行筛选。只有紧邻的同辈元素会被匹配到，而不是前面所有的同辈元素。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="fadeTo">
         <desc>把所有匹配元素的不透明度以渐进方式调整到指定的不透明度，并在动画完成后可选地触发一个回调函数。</desc>
         <signature>
            <argument name="duration">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="opacity">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个动画只调整元素的不透明度，也就是说所有匹配的元素的高度和宽度不会发生变化。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="fadeOut">
         <desc>通过不透明度的变化来实现所有匹配元素的淡出效果，并在动画完成后可选地触发一个回调函数。</desc>
         <signature>
            <argument name="duration">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个动画只调整元素的不透明度，也就是说所有匹配的元素的高度和宽度不会发生变化。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="parents">
         <desc>取得一个包含着所有匹配元素的祖先元素的元素集合（不包含根元素）。可以通过一个可选的表达式进行筛选。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.parents()</code> method allows us to search through the ancestors of these elements in the DOM tree and construct a new jQuery object from the matching elements ordered from immediate parent on up. The <code>.parents()</code> and <code>.parent()</code> methods are similar, except that the latter only travels a single level up the DOM tree.</p>
            <p>The method optionally accepts a selector expression of the same type that we can pass to the <code>$()</code> function. If the selector is supplied, the elements will be filtered by testing whether they match it.</p>
            <p>Consider a page with a basic nested list on it:</p>
            <pre>
&lt;ul class="level-1"&gt;
  &lt;li class="item-i"&gt;I&lt;/li&gt;
  &lt;li class="item-ii"&gt;II
    &lt;ul class="level-2"&gt;
      &lt;li class="item-a"&gt;A&lt;/li&gt;
      &lt;li class="item-b"&gt;B
        &lt;ul class="level-3"&gt;
          &lt;li class="item-1"&gt;1&lt;/li&gt;
          &lt;li class="item-2"&gt;2&lt;/li&gt;
          &lt;li class="item-3"&gt;3&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li class="item-c"&gt;C&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li class="item-iii"&gt;III&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>If we begin at item A, we can find its ancestors:</p>
            <pre>$('li.item-a').parents().css('background-color', 'red');</pre>
            <p>The result of this call is a red background for the level-2 list, item II, and the level-1 list (and on up the DOM tree all the way to the <code>&lt;html&gt;</code> element). Since we do not supply a selector expression, all of the ancestors are part of the returned jQuery object. If we had supplied one, only the matching items among these would be included.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="fadeIn">
         <desc>通过不透明度的变化来实现所有匹配元素的淡入效果，并在动画完成后可选地触发一个回调函数。</desc>
         <signature>
            <argument name="duration">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个动画只调整元素的不透明度，也就是说所有匹配的元素的高度和宽度不会发生变化。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="parent">
         <desc>取得一个包含着所有匹配元素的唯一父元素的元素集合。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>你可以使用可选的表达式来筛选。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="offsetParent">
         <desc>返回第一个匹配元素用于定位的父节点。</desc>
         <signature/>
         <longdesc>这返回父元素中第一个其position设为relative或者absolute的元素。此方法仅对可见元素有效。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="slideToggle">
         <desc>通过高度变化来切换所有匹配元素的可见性，并在切换完成后可选地触发一个回调函数。</desc>
         <signature>
            <argument name="duration">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式隐藏或显示。在jQuery 1.3中，上下的padding和margin也会有动画，效果更流畅。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.post">
         <desc>通过远程 HTTP POST 请求载入信息。</desc>
         <signature>
            <argument name="url">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="data">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="success(data, textStatus, XMLHttpRequest)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="dataType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这是一个简单的 POST 请求功能以取代复杂 $.ajax 。请求成功时可调用回调函数。如果需要在出错时执行函数，请使用 $.ajax。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="slideUp">
         <desc>通过高度变化（向上减小）来动态地隐藏所有匹配的元素，在隐藏完成后可选地触发一个回调函数。</desc>
         <signature>
            <argument name="duration">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式隐藏起来。在jQuery 1.3中，上下的padding和margin也会有动画，效果更流畅。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="nextAll">
         <desc>查找当前元素之后所有的同辈元素。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>可以用表达式过滤</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="next">
         <desc>取得一个包含匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个函数只返回后面那个紧邻的同辈元素，而不是后面所有的同辈元素（可以使用nextAll）。可以用一个可选的表达式进行筛选。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="slideDown">
         <desc>通过高度变化（向下增大）来动态地显示所有匹配的元素，在显示完成后可选地触发一个回调函数。</desc>
         <signature>
            <argument name="duration">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个动画效果只调整元素的高度，可以使匹配的元素以“滑动”的方式显示出来。在jQuery 1.3中，上下的padding和margin也会有动画，效果更流畅。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="find">
         <desc>搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>所有搜索都依靠jQuery表达式来完成。这个表达式可以使用CSS1-3的选择器语法来写。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.getScript">
         <desc>通过 HTTP GET 请求载入并执行一个 JavaScript 文件。</desc>
         <signature>
            <argument name="url">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="success(data, textStatus)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>jQuery 1.2 版本之前，getScript 只能调用同域 JS 文件。 1.2中，您可以跨域调用 JavaScript 文件。注意：Safari 2 或更早的版本不能在全局作用域中同步执行脚本。如果通过 getScript 加入脚本，请加入延时函数。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="contents">
         <desc>查找匹配元素内部所有的子节点（包括文本节点）。如果元素是一个iframe，则查找文档内容</desc>
         <signature/>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.contents()</code> method allows us to search through the immediate children of these elements in the DOM tree and construct a new jQuery object from the matching elements. The <code>.contents()</code> and <code>.children()</code> methods are similar, except that the former includes text nodes as well as HTML elements in the resulting jQuery object.</p>
            <p>The <code>.contents()</code> method can also be used to get the content document of an iframe, if the iframe is on the same domain as the main page.</p>
            <p>Consider a simple <code>&lt;div&gt;</code> with a number of text nodes, each of which is separated by two line break elements (<code>&lt;br /&gt;</code>):</p>
            <pre>&lt;div class="container"&gt;
  Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed 
  do eiusmod tempor incididunt ut labore et dolore magna aliqua. 
  &lt;br /&gt;&lt;br /&gt;
  Ut enim ad minim veniam, quis nostrud exercitation ullamco 
  laboris nisi ut aliquip ex ea commodo consequat.
  &lt;br /&gt; &lt;br /&gt;
  Duis aute irure dolor in reprehenderit in voluptate velit 
  esse cillum dolore eu fugiat nulla pariatur.
&lt;/div&gt;
</pre>
            <p>We can employ the <code>.contents()</code> method to help convert this blob of text into three well-formed paragraphs:</p>
            <pre>
$('.container').contents().filter(function() {
  return this.nodeType == 3;
})
  .wrap('&lt;p&gt;&lt;/p&gt;')
.end()
.filter('br')
  .remove();
</pre>
            <p>This code first retrieves the contents  of <code>&lt;div class="container"&gt;</code> and then filters it for text nodes, which are wrapped in paragraph tags. This is accomplished by testing the <a href="https://developer.mozilla.org/en/nodeType">
                  <code>.nodeType</code> property</a> of the element. This DOM property holds a numeric code indicating the node's type; text nodes use the code 3. The contents are again filtered, this time for <code>&lt;br /&gt;</code> elements, and these elements are removed.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="closest">
         <desc>jQuery 1.3新增。从元素本身开始，逐级向上级元素匹配，并返回最先匹配的元素。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="context">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>closest会首先检查当前元素是否匹配，如果匹配则直接返回元素本身。如果不匹配则向上查找父元素，一层一层往上，直到找到匹配选择器的元素。如果什么都没找到则返回一个空的jQuery对象。

		closest和parents的主要区别是：1，前者从当前元素开始匹配寻找，后者从父元素开始匹配寻找；2，前者逐级向上查找，直到发现匹配的元素后就停止了，后者一直向上查找直到根元素，然后把这些元素放进一个临时集合中，再用给定的选择器表达式去过滤；3，前者返回0或1个元素，后者可能包含0个，1个，或者多个元素。		

		closest对于处理事件委托非常有用。
</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="closest">
         <desc>jQuery 1.3新增。从元素本身开始，逐级向上级元素匹配，并返回最先匹配的元素。</desc>
         <signature>
            <argument name="selectors">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="context">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>closest会首先检查当前元素是否匹配，如果匹配则直接返回元素本身。如果不匹配则向上查找父元素，一层一层往上，直到找到匹配选择器的元素。如果什么都没找到则返回一个空的jQuery对象。

		closest和parents的主要区别是：1，前者从当前元素开始匹配寻找，后者从父元素开始匹配寻找；2，前者逐级向上查找，直到发现匹配的元素后就停止了，后者一直向上查找直到根元素，然后把这些元素放进一个临时集合中，再用给定的选择器表达式去过滤；3，前者返回0或1个元素，后者可能包含0个，1个，或者多个元素。		

		closest对于处理事件委托非常有用。
</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.getJSON">
         <desc>通过 HTTP GET 请求载入 JSON 数据。</desc>
         <signature>
            <argument name="url">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="data">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback(data, textStatus)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>在 jQuery 1.2 中，您可以通过使用&lt;a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/" class="external text" title="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/"&gt;JSONP&lt;/a&gt; 形式的回调函数来加载其他网域的JSON数据，如 "myurl?callback=?"。jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。  注意：此行以后的代码将在这个回调函数执行前执行。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.get">
         <desc>通过远程 HTTP GET 请求载入信息。</desc>
         <signature>
            <argument name="url">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="data">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback(data, textStatus, XMLHttpRequest)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="dataType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这是一个简单的 GET 请求功能以取代复杂 $.ajax 。请求成功时可调用回调函数。如果需要在出错时执行函数，请使用 $.ajax。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="load">
         <desc>在每一个匹配元素的load事件中绑定一个处理函数。 载入远程 HTML 文件代码并插入至 DOM 中。</desc>
         <signature>
            <argument name="url">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="data">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="complete(responseText, textStatus, XMLHttpRequest)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果绑定给window对象，则会在所有内容加载后触发，包括窗口，框架，对象和图像。如果绑定在元素上，则当元素的内容加载完毕后触发。

'''注意:'''只有当在这个元素完全加载完之前绑定load的处理函数,才会在他加载完后触发。如果之后再绑定就永远不会触发了。所以'''不要'''在$(document).ready()里绑定load事件，因为jQuery会在所有DOM加载完成后再绑定load事件。默认使用 GET 方式 - 传递附加参数时自动转换为 POST 方式。jQuery 1.2 中，可以指定选择符，来筛选载入的 HTML 文档，DOM 中将仅插入筛选出的 HTML 代码。语法形如 "url #some &gt; selector"。请查看示例。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.ajax">
         <desc>通过 HTTP 请求加载远程数据。</desc>
         <signature>
            <argument name="settings">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <option name="async">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="beforeSend(XMLHttpRequest)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="cache">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="complete(XMLHttpRequest, textStatus)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="contentType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="context">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="data">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="dataFilter(data, type)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="dataType">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="error(XMLHttpRequest, textStatus, errorThrown)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="global">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="ifModified">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="jsonp">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="jsonpCallback">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="password">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="processData">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="scriptCharset">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="success(data, textStatus, XMLHttpRequest)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="timeout">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="traditional">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="type">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="url">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="username">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
            <option name="xhr">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </option>
         </signature>
         <longdesc>jQuery 底层 AJAX 实现。简单易用的高层实现见 $.get, $.post 等。$.ajax() 返回其创建的 XMLHttpRequest 对象。大多数情况下你无需直接操作该函数，除非你需要操作不常用的选项，以获得更多的灵活性。

最简单的情况下，$.ajax()可以不带任何参数直接使用。

'''注意'''，所有的选项都可以通过$.ajaxSetup()函数来全局设置。

'''回调函数'''

如果要处理$.ajax()得到的数据，则需要使用回调函数。beforeSend、error、dataFilter、success、complete。

&lt;ul&gt;
    &lt;li&gt;beforeSend 在发送请求之前调用，并且传入一个XMLHttpRequest作为参数。&lt;/li&gt;
    &lt;li&gt;error 在请求出错时调用。传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象（如果有的话）&lt;/li&gt;
    &lt;li&gt;dataFilter 在请求成功之后调用。传入返回的数据以及"dataType"参数的值。并且必须返回新的数据（可能是处理过的）传递给success回调函数。&lt;/li&gt;
    &lt;li&gt;success 当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。&lt;/li&gt;
    &lt;li&gt;complete 当请求完成之后调用这个函数，无论成功或失败。传入XMLHttpRequest对象，以及一个包含成功或错误代码的字符串。&lt;/li&gt;
&lt;/ul&gt;

'''数据类型'''

$.ajax()函数依赖服务器提供的信息来处理返回的数据。如果服务器报告说返回的数据是XML，那么返回的结果就可以用普通的XML方法或者jQuery的选择器来遍历。如果见得到其他类型，比如HTML，则数据就以文本形式来对待。

通过dataType选项还可以指定其他不同数据处理方式。除了单纯的XML，还可以指定 html、json、jsonp、script或者text。

其中，text和xml类型返回的数据不会经过处理。数据仅仅简单的将XMLHttpRequest的responseText或responseHTML属性传递给success回调函数，

'''注意'''，我们必须确保网页服务器报告的MIME类型与我们选择的dataType所匹配。比如说，XML的话，服务器端就必须声明 text/xml 或者 application/xml 来获得一致的结果。

如果指定为html类型，任何内嵌的JavaScript都会在HTML作为一个字符串返回之前执行。类似的，指定script类型的话，也会先执行服务器端生成JavaScript，然后再把脚本作为一个文本数据返回。

如果指定为json类型，则会把获取到的数据作为一个JavaScript对象来解析，并且把构建好的对象作为结果返回。为了实现这个目的，他首先尝试使用JSON.parse()。如果浏览器不支持，则使用一个函数来构建。JSON数据是一种能很方便通过JavaScript解析的结构化数据。如果获取的数据文件存放在远程服务器上（域名不同，也就是跨域获取数据），则需要使用jsonp类型。使用这种类型的话，会创建一个查询字符串参数 callback=? ，这个参数会加在请求的URL后面。服务器端应当在JSON数据前加上回调函数名，以便完成一个有效的JSONP请求。如果要指定回调函数的参数名来取代默认的callback，可以通过设置$.ajax()的jsonp参数。

'''注意'''，JSONP是JSON格式的扩展。他要求一些服务器端的代码来检测并处理查询字符串参数。更多信息可以参阅 &lt;a href="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/"&gt;最初的文章&lt;/a&gt;。

如果指定了script或者jsonp类型，那么当从服务器接收到数据时，实际上是用了&amp;lt;script&amp;gt;标签而不是XMLHttpRequest对象。这种情况下，$.ajax()不再返回一个XMLHttpRequest对象，并且也不会传递事件处理函数，比如beforeSend。

'''发送数据到服务器'''

默认情况下，Ajax请求使用GET方法。如果要使用POST方法，可以设定type参数值。这个选项也会影响data选项中的内容如何发送到服务器。

data选项既可以包含一个查询字符串，比如 key1=value1&amp;amp;key2=value2 ，也可以是一个映射，比如 {key1: 'value1', key2: 'value2'} 。如果使用了后者的形式，则数据再发送器会被转换成查询字符串。这个处理过程也可以通过设置processData选项为false来回避。如果我们希望发送一个XML对象给服务器时，这种处理可能并不合适。并且在这种情况下，我们也应当改变contentType选项的值，用其他合适的MIME类型来取代默认的  application/x-www-form-urlencoded 。

'''高级选项'''

global选项用于阻止响应注册的回调函数，比如.ajaxSend，或者ajaxError，以及类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以在ajaxSend里禁用这个。更多关于这些方法的详细信息，请参阅下面的内容。

如果服务器需要HTTP认证，可以使用用户名和密码可以通过username和password选项来设置。

Ajax请求是限时的，所以错误警告被捕获并处理后，可以用来提升用户体验。请求超时这个参数通常就保留其默认值，要不就通过jQuery.ajaxSetup来全局设定，很少为特定的请求重新设置timeout选项。

默认情况下，请求总会被发出去，但浏览器有可能从他的缓存中调取数据。要禁止使用缓存的结果，可以设置cache参数为false。如果希望判断数据自从上次请求后没有更改过就报告出错的话，可以设置ifModified为true。

scriptCharset允许给&amp;lt;script&amp;gt;标签的请求设定一个特定的字符集，用于script或者jsonp类似的数据。当脚本和页面字符集不同时，这特别好用。

Ajax的第一个字母是asynchronous的开头字母，这意味着所有的操作都是并行的，完成的顺序没有前后关系。$.ajax()的async参数总是设置成true，这标志着在请求开始后，其他代码依然能够执行。强烈不建议把这个选项设置成false，这意味着所有的请求都不再是异步的了，这也会导致浏览器被锁死。

$.ajax函数返回他创建的XMLHttpRequest对象。通常jQuery只在内部处理并创建这个对象，但用户也可以通过xhr选项来传递一个自己创建的xhr对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的.abort()可以在请求完成前挂起请求。
</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="length">
         <desc>jQuery 对象中元素的个数。</desc>
         <signature/>
         <longdesc>当前匹配的元素个数。 &lt;span title="Core/size"&gt;size&lt;/span&gt; 将返回相同的值。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="children">
         <desc>取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>可以通过可选的表达式来过滤所匹配的子元素。注意：parents()将查找所有祖辈元素，而children()只考虑子元素而不考虑所有后代元素。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="selector">
         <desc>jQuery 1.3新增。返回传给jQuery()的原始选择器。</desc>
         <signature/>
         <longdesc>换句话说，就是返回你用什么选择器来找到这个元素的。可以与&lt;span title="Core/context"&gt;context&lt;/span&gt;一起使用，用于精确检测选择器查询情况。这两个属性对插件开发人员很有用。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="add">
         <desc>把与表达式匹配的元素添加到jQuery对象中。这个函数可以用于连接分别与两个表达式匹配的元素结果集。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="elements">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="html">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="context">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>jQuery 1.4 中， .add()方法返回的结果将始终以元素在HTML文档中出现的顺序来排序，而不再是简单的添加。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="context">
         <desc>jQuery 1.3新增。返回传给jQuery()的原始的DOM节点内容，即jQuery()的第二个参数。如果没有指定，那么context指向当前的文档(document)。</desc>
         <signature/>
         <longdesc>可以与&lt;span title="Core/selector"&gt;selector&lt;/span&gt;一起使用，用于精确检测选择器查询情况。这两个属性对插件开发人员很有用。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="not">
         <desc>删除与指定表达式匹配的元素</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="elements">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>Given a jQuery object that represents a set of DOM elements, the <code>.not()</code> method constructs a new jQuery object from a subset of the matching elements. The supplied selector is tested against each element; the elements that don't match the selector will be included in the result.</p>
            <p>Consider a page with a simple list on it:</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2&lt;/li&gt;
  &lt;li&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
  &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>We can apply this method to the set of list items:</p>
            <pre>$('li').not(':even').css('background-color', 'red');</pre>
            <p>The result of this call is a red background for items 2 and 4, as they do not match the selector (recall that :even and :odd use 0-based indexing).</p>
            <h4>Removing Specific Elements</h4>
            <p>The second version of the <code>.not()</code> method allows us to remove elements from the matched set, assuming we have found those elements previously by some other means. For example, suppose our list had an id applied to one of its items:</p>
            <pre>
&lt;ul&gt;
  &lt;li&gt;list item 1&lt;/li&gt;
  &lt;li&gt;list item 2&lt;/li&gt;
  &lt;li id="notli"&gt;list item 3&lt;/li&gt;
  &lt;li&gt;list item 4&lt;/li&gt;
  &lt;li&gt;list item 5&lt;/li&gt;
&lt;/ul&gt;
</pre>
            <p>We can fetch the third list item using the native JavaScript <code>getElementById()</code> function, then remove it from a jQuery object:</p>
            <pre>
$('li').not(document.getElementById('notli'))
  .css('background-color', 'red');
</pre>
            <p>This statement changes the color of items 1, 2, 4, and 5. We could have accomplished the same thing with a simpler jQuery expression, but this technique can be useful when, for example, other libraries provide references to plain DOM nodes.</p>
            <p>As of jQuery 1.4, the <code>.not()</code> method can take a function as its argument in the same way that <code>.filter()</code> does. Elements for which the function returns <code>true</code> are excluded from the filtered set; all other elements are included.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="outerWidth">
         <desc>获取第一个匹配元素外部宽度（默认包括补白和边框）。</desc>
         <signature>
            <argument name="includeMargin">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>此方法对可见和隐藏元素均有效。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="outerHeight">
         <desc>获取第一个匹配元素外部高度（默认包括补白和边框）。</desc>
         <signature>
            <argument name="includeMargin">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>此方法对可见和隐藏元素均有效。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="toggle">
         <desc>每次点击后依次调用函数。 切换元素的可见状态。 根据switch参数切换元素的可见状态（ture为可见，false为隐藏）。 以优雅的动画切换所有匹配的元素，并在显示完成后可选地触发一个回调函数。</desc>
         <signature>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="handler(eventObject)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果点击了一个匹配的元素，则触发指定的第一个函数，当再次点击同一元素时，则触发指定的第二个函数，如果有更多函数，则再次触发，直到最后一个。随后的每次点击都重复对这几个函数的轮番调用。

可以使用unbind("click")来删除。如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。如果switch设为true，则调用show()方法来显示匹配的元素，如果switch设为false则调用hide()来隐藏元素。可以根据指定的速度动态地改变每个匹配元素的高度、宽度和不透明度。在jQuery 1.3中，padding和margin也会有动画，效果更流畅。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="toggle">
         <desc>每次点击后依次调用函数。 切换元素的可见状态。 根据switch参数切换元素的可见状态（ture为可见，false为隐藏）。 以优雅的动画切换所有匹配的元素，并在显示完成后可选地触发一个回调函数。</desc>
         <signature>
            <argument name="duration">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="showOrHide">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果点击了一个匹配的元素，则触发指定的第一个函数，当再次点击同一元素时，则触发指定的第二个函数，如果有更多函数，则再次触发，直到最后一个。随后的每次点击都重复对这几个函数的轮番调用。

可以使用unbind("click")来删除。如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。如果switch设为true，则调用show()方法来显示匹配的元素，如果switch设为false则调用hide()来隐藏元素。可以根据指定的速度动态地改变每个匹配元素的高度、宽度和不透明度。在jQuery 1.3中，padding和margin也会有动画，效果更流畅。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="innerWidth">
         <desc>获取第一个匹配元素内部区域宽度（包括补白、不包括边框）。</desc>
         <signature/>
         <longdesc>此方法对可见和隐藏元素均有效。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="innerHeight">
         <desc>获取第一个匹配元素内部区域高度（包括补白、不包括边框）。</desc>
         <signature/>
         <longdesc>此方法对可见和隐藏元素均有效。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.param">
         <desc>将表单元素数组或者对象序列化。是.serialize()的核心方法。</desc>
         <signature>
            <argument name="obj">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="obj">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="traditional">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>在jQuery 1.3中，如果传递的参数是一个函数，那么用.param()会得到这个函数的返回值，而不是把这个函数作为一个字符串来返回。
		
		在jQuery 1.4中，.param()会深度递归一个对象来满足现在脚本语言和框架，比如PHP， Ruby on Rails等。你可以通过jQuery.ajaxSettings.traditional = true; 来全局得禁用这个功能。
		
		注意：因为有些框架在解析序列化数字的时候能力有限，所以当传递一些含有嵌套对象、数组的对象作为参数时，请务必小心！
		
		在jQuery 1.4中，HTML5的input元素也会被序列化。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="hide">
         <desc>隐藏显示的元素 以优雅的动画隐藏所有匹配的元素，并在显示完成后可选地触发一个回调函数。</desc>
         <signature/>
         <signature>
            <argument name="duration">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个就是 'hide( speed, [callback] )' 的无动画版。如果选择的元素是隐藏的，这个方法将不会改变任何东西。可以根据指定的速度动态地改变每个匹配元素的高度、宽度和不透明度。在jQuery 1.3中，padding和margin也会有动画，效果更流畅。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="width">
         <desc>取得第一个匹配元素当前计算的宽度值（px）。 为每个匹配的元素设置CSS宽度(width)属性的值。</desc>
         <signature/>
         <longdesc>在 jQuery 1.2 以后可以用来获取 window 和 document 的宽如果没有明确指定单位（如：em或%），使用px。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="width">
         <desc>取得第一个匹配元素当前计算的宽度值（px）。 为每个匹配的元素设置CSS宽度(width)属性的值。</desc>
         <signature>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index, width)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>在 jQuery 1.2 以后可以用来获取 window 和 document 的宽如果没有明确指定单位（如：em或%），使用px。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="height">
         <desc>取得第一个匹配元素当前计算的高度值（px）。 为每个匹配的元素设置CSS高度(hidth)属性的值。如果没有明确指定单位（如：em或%），使用px。</desc>
         <signature/>
         <longdesc>在 jQuery 1.2 以后可以用来获取 window 和 document 的高如果没有明确指定单位（如：em或%），使用px。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="height">
         <desc>取得第一个匹配元素当前计算的高度值（px）。 为每个匹配的元素设置CSS高度(hidth)属性的值。如果没有明确指定单位（如：em或%），使用px。</desc>
         <signature>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index, height)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>在 jQuery 1.2 以后可以用来获取 window 和 document 的高如果没有明确指定单位（如：em或%），使用px。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="show">
         <desc>显示隐藏的匹配元素。 以优雅的动画显示所有匹配的元素，并在显示完成后可选地触发一个回调函数。</desc>
         <signature/>
         <signature>
            <argument name="duration">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个就是 'show( speed, [callback] )' 无动画的版本。如果选择的元素是可见的，这个方法将不会改变任何东西。无论这个元素是通过hide()方法隐藏的还是在CSS里设置了display:none;，这个方法都将有效。可以根据指定的速度动态地改变每个匹配元素的高度、宽度和不透明度。在jQuery 1.3中，padding和margin也会有动画，效果更流畅。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="scrollLeft">
         <desc>获取匹配元素相对滚动条左侧的偏移。 传递参数值时，设置水平滚动条左侧偏移为该值。</desc>
         <signature/>
         <longdesc>此方法对可见和隐藏元素均有效。此方法对可见和隐藏元素均有效。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="scrollLeft">
         <desc>获取匹配元素相对滚动条左侧的偏移。 传递参数值时，设置水平滚动条左侧偏移为该值。</desc>
         <signature>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>此方法对可见和隐藏元素均有效。此方法对可见和隐藏元素均有效。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.trim">
         <desc>去掉字符串起始和结尾的空格。</desc>
         <signature>
            <argument name="str">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>The <code>$.trim()</code> function removes all newlines, spaces (including non-breaking spaces), and tabs from the beginning and end of the supplied string. If these whitespace characters occur in the middle of the string, they are preserved.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.isFunction">
         <desc>测试对象是否为函数。</desc>
         <signature>
            <argument name="obj">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>'''注意：'''jQuery 1.3以后，在IE浏览器里，浏览器提供的函数比如'alert'还有 DOM 元素的方法比如 'getAttribute' 将不认为是函数</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.isArray">
         <desc>jQuery 1.3 新增。测试对象是否为数组。</desc>
         <signature>
            <argument name="obj">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>
               <code>$.isArray()</code> returns a Boolean indicating whether the object is a JavaScript array (not an array-like object, such as a jQuery object).</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.unique">
         <desc>删除数组中重复元素。只处理删除DOM元素数组，而不能处理字符串或者数字数组。</desc>
         <signature>
            <argument name="array">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>The <code>$.unique()</code> function searches through an array of objects, sorting the array, and removing any duplicate nodes. This function only works on plain JavaScript arrays of DOM elements, and is chiefly used internally by jQuery.</p>
            <p>As of jQuery 1.4 the results will always be returned in document order.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.merge">
         <desc>合并两个数组</desc>
         <signature>
            <argument name="first">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="second">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>返回的结果会修改第一个数组的内容——第一个数组的元素后面跟着第二个数组的元素。要去除重复项，请使用$.unique()</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.inArray">
         <desc>确定第一个参数在数组中的位置，从0开始计数(如果没有找到则返回 -1 )。</desc>
         <signature>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="array">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>The <code>$.inArray()</code> method is similar to JavaScript's native <code>.indexOf()</code> method in that it returns -1 when it doesn't find a match. If the first element within the array matches <code>value</code>, <code>$.inArray()</code> returns 0.</p> 

            <p>Because JavaScript treats 0 as loosely equal to false (i.e. 0 == false, but 0 !== false), if we're checking for the presence of <code>value</code> within <code>array</code>, we need to check if it's not equal to (or greater than) -1.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.map">
         <desc>将一个数组中的元素转换到另一个数组中。</desc>
         <signature>
            <argument name="array">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback(elementOfArray, indexInArray)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>作为参数的转换函数会为每个数组元素调用，而且会给这个转换函数传递一个表示被转换的元素作为参数。转换函数可以返回转换后的值、null（删除数组中的项目）或一个包含值的数组，并扩展至原始数组中。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.makeArray">
         <desc>将类数组对象转换为数组对象。</desc>
         <signature>
            <argument name="obj">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>类数组对象有 length 属性，其成员索引为 0 至 length - 1。实际中此函数在 jQuery 中将自动使用而无需特意转换。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.grep">
         <desc>使用过滤函数过滤数组元素。</desc>
         <signature>
            <argument name="array">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="function(elementOfArray, indexInArray)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="invert">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>此函数至少传递两个参数：待过滤数组和过滤函数。过滤函数必须返回 true 以保留元素或 false 以删除元素。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.extend">
         <desc>扩展jQuery对象本身。 用一个或多个其他对象来扩展一个对象，返回被扩展的对象。</desc>
         <signature>
            <argument name="target">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="object1">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="objectN">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="deep">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="target">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="object1">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="objectN">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>用来在jQuery命名空间上增加新函数。 查看 &lt;span title="Core/jQuery.fn.extend"&gt;'jQuery.fn.extend'&lt;/span&gt; 获取更多添加&lt;a href="http://docs.jquery.com/Plugins/Authoring" title="Plugins/Authoring"&gt;插件&lt;/a&gt;的信息。如果不指定target，则给jQuery命名空间本身进行扩展。这有助于插件作者为jQuery增加新方法。
		
		如果第一个参数设置为true，则jQuery返回一个深层次的副本，递归地复制找到的任何对象。否则的话，副本会与原对象共享结构。
		
		未定义的属性将不会被复制，然而从对象的原型继承的属性将会被复制。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="jQuery.each">
         <desc>通用例遍方法，可用于例遍对象和数组。</desc>
         <signature>
            <argument name="collection">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="callback(indexInArray, valueOfElement)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>不同于例遍 jQuery 对象的 $().each() 方法，此方法可用于例遍任何对象。回调函数拥有两个参数：第一个为对象的成员或数组的索引，第二个为对应变量或内容。如果需要退出 each 循环可使回调函数返回 false，其它返回值将被忽略。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="jQuery.boxModel">
         <desc>在jQuery 1.3中不建议使用。当前页面中浏览器是否使用标准盒模型渲染页面。 建议使用 jQuery.support.boxModel 代替。W3C CSS 盒模型.</desc>
         <signature/>
         <longdesc/>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="scrollTop">
         <desc>获取匹配元素相对滚动条顶部的偏移。 传递参数值时，设置垂直滚动条顶部偏移为该值。</desc>
         <signature/>
         <longdesc>此方法对可见和隐藏元素均有效。此方法对可见和隐藏元素均有效。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="scrollTop">
         <desc>获取匹配元素相对滚动条顶部的偏移。 传递参数值时，设置垂直滚动条顶部偏移为该值。</desc>
         <signature>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>此方法对可见和隐藏元素均有效。此方法对可见和隐藏元素均有效。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="property" name="jQuery.support">
         <desc>jQuery 1.3 新增。一组用于展示不同浏览器各自特性和bug的属性集合。</desc>
         <signature/>
         <longdesc>jQuery提供了一系列属性，你也可以自由增加你自己的属性。其中许多属性是很低级的，所以很难说他们能否在日新月异的发展中一直保持有效，但这这些主要用于插件和内核开发者。

所有这些支持的属性值都通过特性检测来实现，而不是用任何浏览器检测。以下有一些非常棒的资源用于解释这些特性检测是如何工作的：&lt;ul&gt;&lt;li&gt;http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting&lt;/li&gt;&lt;li&gt;http://yura.thinkweb2.com/cft/&lt;/li&gt;&lt;li&gt;http://www.jibbering.com/faq/faq_notes/not_browser_detect.html&lt;/li&gt;&lt;/ul&gt;jQuery.support主要包括以下测试：

'''boxModel''': 如果这个页面和浏览器是以W3C CSS盒式模型来渲染的，则等于true。通常在IE 6和IE 7的怪癖模式中这个值是false。在document准备就绪前，这个值是null。

'''cssFloat''': 如果用cssFloat来访问CSS的float的值，则返回true。目前在IE中会返回false,他用styleFloat代替。

'''hrefNormalized''': 如果浏览器从getAttribute("href")返回的是原封不动的结果，则返回true。在IE中会返回false，因为他的URLs已经常规化了。

'''htmlSerialize''': 如果浏览器通过innerHTML插入链接元素的时候会序列化这些链接，则返回true，目前IE中返回false。

'''leadingWhitespace''': 如果在使用innerHTML的时候浏览器会保持前导空白字符，则返回true，目前在IE 6-8中返回false。

'''noCloneEvent''': 如果浏览器在克隆元素的时候不会连同事件处理函数一起复制，则返回true，目前在IE中返回false。

'''objectAll''': 如果在某个元素对象上执行getElementsByTagName("*")会返回所有子孙元素，则为true，目前在IE 7中为false。

'''opacity''': 如果浏览器能适当解释透明度样式属性，则返回true，目前在IE中返回false，因为他用alpha滤镜代替。

'''scriptEval''': 使用 appendChild/createTextNode 方法插入脚本代码时，浏览器是否执行脚本，目前在IE中返回false，IE使用 .text 方法插入脚本代码以执行。

'''style''': 如果getAttribute("style")返回元素的行内样式，则为true。目前IE中为false，因为他用cssText代替。

'''tbody''': 如果浏览器允许table元素不包含tbody元素，则返回true。目前在IE中会返回false，他会自动插入缺失的tbody。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="position">
         <desc>获取匹配元素相对父元素的偏移。</desc>
         <signature/>
         <longdesc>返回的对象包含两个整型属性：top 和 left。为精确计算结果，请在补白、边框和填充属性上使用像素单位。此方法只对可见元素有效。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="offset">
         <desc>获取匹配元素在当前视口的相对偏移。 设置匹配元素相对于document对象的坐标。</desc>
         <signature/>
         <longdesc>返回的对象包含两个整型属性：top 和 left。此方法只对可见元素有效。.offset()方法可以让我们重新设置元素的位置。这个元素的位置是相对于document对象的。如果对象原先的position样式属性是static的话，会被改成relative来实现重定位。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="offset">
         <desc>获取匹配元素在当前视口的相对偏移。 设置匹配元素相对于document对象的坐标。</desc>
         <signature>
            <argument name="coordinates">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index, coords)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>返回的对象包含两个整型属性：top 和 left。此方法只对可见元素有效。.offset()方法可以让我们重新设置元素的位置。这个元素的位置是相对于document对象的。如果对象原先的position样式属性是static的话，会被改成relative来实现重定位。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="css">
         <desc>访问第一个匹配元素的样式属性。 把一个“名/值对”对象设置为所有匹配元素的样式属性。 在所有匹配的元素中，设置一个样式属性的值。 在所有匹配的元素中，设置一个样式属性的值。</desc>
         <signature>
            <argument name="propertyName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这是一种在所有匹配的元素上设置大量样式属性的最佳方式。数字将自动转化为像素值数字将自动转化为像素值</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="css">
         <desc>访问第一个匹配元素的样式属性。 把一个“名/值对”对象设置为所有匹配元素的样式属性。 在所有匹配的元素中，设置一个样式属性的值。 在所有匹配的元素中，设置一个样式属性的值。</desc>
         <signature>
            <argument name="propertyName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="propertyName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="function(index, value)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="map">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这是一种在所有匹配的元素上设置大量样式属性的最佳方式。数字将自动转化为像素值数字将自动转化为像素值</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="unwrap">
         <desc>这个方法将移出元素的父元素。这能快速取消 .wrap()方法的效果。匹配的元素（以及他们的同辈元素）会在DOM结构上替换他们的父元素。</desc>
         <signature/>
         <longdesc>
            <p>The <code>.unwrap()</code> method removes the element's parent. This is effectively the inverse of the <code>
                  <a href="/wrap">.wrap()</a>
               </code> method. The matched elements (and their siblings, if any) replace their parents within the DOM structure.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="detach">
         <desc>从DOM中删除所有匹配的元素。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="clone">
         <desc>克隆匹配的DOM元素并且选中这些克隆的副本。 元素以及其所有的事件处理并且选中这些克隆的副本</desc>
         <signature>
            <argument name="withDataAndEvents">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>在想把DOM文档中元素的副本添加到其他位置时这个函数非常有用。在想把DOM文档中元素的副本添加到其他位置时这个函数非常有用。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="remove">
         <desc>从DOM中删除所有匹配的元素。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。但除了这个元素本身得以保留之外，其他的比如绑定的事件，附加的数据等都会被移除。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="empty">
         <desc>删除匹配的元素集合中所有的子节点。</desc>
         <signature/>
         <longdesc>
            <p>This method removes not only child (and other descendant) elements, but also any text within the set of matched elements. This is because, according to the DOM specification, any string of text within an element is considered a child node of that element. Consider the following HTML:</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="hello"&gt;Hello&lt;/div&gt;
  &lt;div class="goodbye"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>We can target any element for removal:</p>
            <pre>$('.hello').empty();</pre>
            <p>This will result in a DOM structure with the <code>Hello</code> text deleted:</p>
            <pre>&lt;div class="container"&gt;
  &lt;div class="hello"&gt;&lt;/div&gt;
  &lt;div class="goodbye"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>If we had any number of nested elements inside <code>&lt;div class="hello"&gt;</code>, they would be removed, too. </p>
            <p>To avoid memory leaks, jQuery removes other constructs such as data and event handlers from the child elements before removing the elements themselves.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="replaceAll">
         <desc>用匹配的元素替换掉所有 selector匹配到的元素。</desc>
         <signature/>
         <longdesc>在jQuery 1.3.2中，appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，要选择先前选中的元素，需要使用end()方法，参见 appendTo 方法的例二。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="replaceWith">
         <desc>将所有匹配的元素替换成指定的HTML或DOM元素。</desc>
         <signature>
            <argument name="newContent">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>The <code>.replaceWith()</code> method allows us to remove content from the DOM and insert new content in its place with a single call. Consider this DOM structure:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="inner first"&gt;Hello&lt;/div&gt;
  &lt;div class="inner second"&gt;And&lt;/div&gt;
  &lt;div class="inner third"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>We can replace the second inner <code>&lt;div&gt;</code> with specified HTML:</p>
				        <pre>$('.second').replaceWith('&lt;h2&gt;New heading&lt;/h2&gt;');</pre>
				        <p>This results in the structure:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="inner first"&gt;Hello&lt;/div&gt;
  &lt;h2&gt;New heading&lt;/h2&gt;
  &lt;div class="inner third"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>We could equally target all inner <code>&lt;div&gt;</code> elements at once:</p>
				        <pre>$('.inner').replaceWith('&lt;h2&gt;New heading&lt;/h2&gt;');</pre>
				        <p>This causes all of them to be replaced:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;h2&gt;New heading&lt;/h2&gt;
  &lt;h2&gt;New heading&lt;/h2&gt;
  &lt;h2&gt;New heading&lt;/h2&gt;
&lt;/div&gt;</pre>
				        <p>Or, we could select an element to use as the replacement:</p>
				        <pre>$('.third').replaceWith($('.first'));</pre>
				        <p>This results in the DOM structure:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="inner second"&gt;And&lt;/div&gt;
  &lt;div class="inner first"&gt;Hello&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>From this example, we can see that the selected element replaces the target by being moved from its old location, not by being cloned.</p>
				        <p>The <code>.replaceWith()</code> method, like most jQuery methods, returns the jQuery object so that other methods can be chained onto it. However, it must be noted that the <emphasis role="italics">original</emphasis> jQuery object is returned. This object refers to the element that has been removed from the DOM, not the new element that has replaced it.</p>
            <p>In jQuery 1.4 <code>.replaceWith()</code>, <code>.before()</code>, and <code>.after()</code> can also work on disconnected DOM nodes. For example, with the following code:</p>
            <pre>$("&lt;div/&gt;").replaceWith("&lt;p&gt;&lt;/p&gt;");</pre>
            <p>The <code>.replaceWith()</code> method returns a jQuery set containing only a paragraph.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="wrapInner">
         <desc>将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来 将每一个匹配的元素的子内容(包括文本节点)用DOM元素包裹起来 将每一个匹配的元素的子内容(包括文本节点)用DOM元素包裹起来</desc>
         <signature>
            <argument name="wrappingElement">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="wrappingFunction">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个函数的原理是检查提供的第一个元素（它是由所提供的HTML标记代码动态生成的），并在它的代码结构中找到最上层的祖先元素－－这个祖先元素就是包装元素。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="wrapAll">
         <desc>将所有匹配的元素用单个元素包裹起来 将所有匹配的元素用单个元素包裹起来</desc>
         <signature>
            <argument name="wrappingElement">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这于 '.wrap()'&lt;a href="http://docs.jquery.com/Manipulation/wrap" title="Manipulation/wrap"&gt;&lt;/a&gt; 是不同的，'.wrap()'为每一个匹配的元素都包裹一次。这种包装对于在文档中插入额外的结构化标记最有用，而且它不会破坏原始文档的语义品质。这个函数的原理是检查提供的第一个元素并在它的代码结构中找到最上层的祖先元素－－这个祖先元素就是包装元素。这于 '.wrap()'&lt;a href="http://docs.jquery.com/Manipulation/wrap" title="Manipulation/wrap"&gt;&lt;/a&gt; 是不同的，'.wrap()'为每一个匹配的元素都包裹一次。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="wrap">
         <desc>把所有匹配的元素用其他元素的结构化标记包裹起来。 把所有匹配的元素用其他元素的结构化标记包装起来。 把所有匹配的元素用其他元素的结构化标记包装起来。</desc>
         <signature>
            <argument name="wrappingElement">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="wrappingFunction">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这种包装对于在文档中插入额外的结构化标记最有用，而且它不会破坏原始文档的语义品质。这个函数的原理是检查提供的第一个元素（它是由所提供的HTML标记代码动态生成的），并在它的代码结构中找到最上层的祖先元素－－这个祖先元素就是包裹元素。当HTML标记代码中的元素包含文本时无法使用这个函数。因此，如果要添加文本应该在包裹完成之后再行添加。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="insertBefore">
         <desc>把所有匹配的元素插入到另一个、指定的元素元素集合的前面。</desc>
         <signature>
            <argument name="target">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>实际上，使用这个方法是颠倒了常规的$(A).before(B)的操作，即不是把B插入到A前面，而是把A插入到B前面。

		在jQuery 1.3.2中，appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，要选择先前选中的元素，需要使用end()方法，参见 appendTo 方法的例二。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="before">
         <desc>在每个匹配的元素之前插入内容。 在每个匹配的元素之前插入内容。</desc>
         <signature>
            <argument name="content">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>The <code>.before()</code> and <code>
                  <a href="/insertBefore">.insertBefore()</a>
               </code> methods perform the same task. The major difference is in the syntax-specifically, in the placement of the content and target. With<code> .before()</code>, the selector expression preceding the method is the container before which the content is inserted. With <code>.insertBefore()</code>, on the other hand, the content precedes the method, either as a selector expression or as markup created on the fly, and it is inserted before the target container.</p>
				        <p>Consider the following HTML:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>We can create content and insert it before several elements at once:</p>
				        <pre>$('.inner').before('&lt;p&gt;Test&lt;/p&gt;');</pre>
				        <p>Each inner <code>&lt;div&gt;</code> element gets this new content:</p>
            <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;p&gt;Test&lt;/p&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;p&gt;Test&lt;/p&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>We can also select an element on the page and insert it before another:</p>
				        <pre>$('.container').before($('h2'));</pre>
				        <p>If an element selected this way is inserted elsewhere, it will be moved before the target (not cloned):</p>
				        <pre>&lt;h2&gt;Greetings&lt;/h2&gt;
&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>If there is more than one target element, however, cloned copies of the inserted element will be created for each target after the first.</p>
            <p>In jQuery 1.4, <code>.before()</code> and <code>.after()</code> will also work on disconnected DOM nodes:</p>
            <pre>$("&lt;div/&gt;").before("&lt;p&gt;&lt;/p&gt;");</pre>
            <p>The result is a jQuery set that contains a paragraph and a div (in that order).</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="insertAfter">
         <desc>把所有匹配的元素插入到另一个、指定的元素元素集合的后面。</desc>
         <signature>
            <argument name="target">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>实际上，使用这个方法是颠倒了常规的$(A).after(B)的操作，即不是把B插入到A后面，而是把A插入到B后面。

		在jQuery 1.3.2中，appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，要选择先前选中的元素，需要使用end()方法，参见 appendTo 方法的例二。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="after">
         <desc>在每个匹配的元素之后插入内容。 在每个匹配的元素之后插入内容。</desc>
         <signature>
            <argument name="content">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>The <code>.after()</code> and <code>
                  <a href="/insertAfter">.insertAfter()</a>
               </code> methods perform the same task. The major difference is in the syntax—specifically, in the placement of the content and target. With<code> .after()</code>, the selector expression preceding the method is the container after which the content is inserted. With <code>.insertAfter()</code>, on the other hand, the content precedes the method, either as a selector expression or as markup created on the fly, and it is inserted after the target container.</p>
				        <p>Consider the following HTML:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>We can create content and insert it after several elements at once:</p>
				        <pre>$('.inner').after('&lt;p&gt;Test&lt;/p&gt;');</pre>
				        <p>Each inner <code>&lt;div&gt;</code> element gets this new content:</p>
				        <pre>&lt;div class="container"&gt;
  &lt;h2&gt;Greetings&lt;/h2&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;p&gt;Test&lt;/p&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
  &lt;p&gt;Test&lt;/p&gt;
&lt;/div&gt;</pre>
				        <p>We can also select an element on the page and insert it after another:</p>
				        <pre>$('.container').after($('h2'));</pre>
				        <p>If an element selected this way is inserted elsewhere, it will be moved after the target (not cloned):</p>
				        <pre>&lt;div class="container"&gt;
  &lt;div class="inner"&gt;Hello&lt;/div&gt;
  &lt;div class="inner"&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;Greetings&lt;/h2&gt;</pre>
				        <p>If there is more than one target element, however, cloned copies of the inserted element will be created for each target after the first.</p>
            <h4 id="disconnected-dom-nodes">Inserting Disconnected DOM nodes</h4>
            <p>As of jQuery 1.4, <code>.before()</code> and <code>.after()</code> will also work on disconnected DOM nodes. For example, given the following code:</p>
            <pre>$('&lt;div/&gt;').after('&lt;p&gt;&lt;/p&gt;');</pre>
            <p>The result is a jQuery set containing a div and a paragraph, in that order. We can further manipulate that set, even before inserting it in the document.</p>
            <pre>$('&lt;div/&gt;').after('&lt;p&gt;&lt;/p&gt;').addClass('foo')
  .filter('p').attr('id', 'bar').html('hello')
.end()
.appendTo('body');</pre>
            <p>This results in the following elements inserted just before the closing <code>&lt;/body&gt;</code> tag:</p>
            <pre>
&lt;div class="foo"&gt;&lt;/div&gt;
&lt;p class="foo" id="bar"&gt;hello&lt;/p&gt;
</pre>
            <p>As of jQuery 1.4, <code>.after()</code> allows us to pass a function that returns the elements to insert.</p>
            <pre>$('p').after(function() {
  return '&lt;div&gt;' + this.className + '&lt;/div&gt;';
});</pre>
            <p>This inserts a <code>&lt;div&gt;</code> after each paragraph, containing the class name(s) of each paragraph in turn.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="prependTo">
         <desc>把所有匹配的元素前置到另一个、指定的元素元素集合中。</desc>
         <signature>
            <argument name="target">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>实际上，使用这个方法是颠倒了常规的$(A).prepend(B)的操作，即不是把B前置到A中，而是把A前置到B中。

		在jQuery 1.3.2中，appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，要选择先前选中的元素，需要使用end()方法，参见 appendTo 方法的例二。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="prepend">
         <desc>向每个匹配的元素内部前置内容。 jQuery 1.4 新增。向每个匹配的元素内部最前面追加内容。</desc>
         <signature>
            <argument name="content">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index, html)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这是向所有匹配元素内部的开始处插入内容的最佳方式。这个操作与对指定的元素执行appendChild方法，将它们添加到文档中的情况类似。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="appendTo">
         <desc>把所有匹配的元素追加到另一个指定的元素元素集合中。</desc>
         <signature>
            <argument name="target">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>实际上，使用这个方法是颠倒了常规的$(A).append(B)的操作，即不是把B追加到A中，而是把A追加到B中。
		
		在jQuery 1.3.2中，appendTo, prependTo, insertBefore, insertAfter, 和 replaceAll这个几个方法成为一个破坏性操作，返回值是所有被追加的内容，而不仅仅是先前所选中的元素。所以，要选择先前选中的元素，需要使用end()方法，参见例二。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="append">
         <desc>向每个匹配的元素内部追加内容。 jQuery 1.4 新增。向每个匹配的元素内部追加内容。</desc>
         <signature>
            <argument name="content">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index, html)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个操作与对指定的元素执行appendChild方法，将它们添加到文档中的情况类似。这个操作与对指定的元素执行appendChild方法，将它们添加到文档中的情况类似。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="val">
         <desc>获得第一个匹配元素的当前值。 设置每一个匹配元素的值。 check,select,radio等都能使用为之赋值 设置每一个匹配元素的值。</desc>
         <signature/>
         <longdesc>在 jQuery 1.2 中,可以返回任意元素的值了。包括select。如果多选，将返回一个数组，其包含所选的值。在 jQuery 1.2, 这也可以为select元件赋值在 jQuery 1.2, 这也可以为select元件赋值</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="val">
         <desc>获得第一个匹配元素的当前值。 设置每一个匹配元素的值。 check,select,radio等都能使用为之赋值 设置每一个匹配元素的值。</desc>
         <signature>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index, value)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>在 jQuery 1.2 中,可以返回任意元素的值了。包括select。如果多选，将返回一个数组，其包含所选的值。在 jQuery 1.2, 这也可以为select元件赋值在 jQuery 1.2, 这也可以为select元件赋值</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="text">
         <desc>取得所有匹配元素的内容。 设置所有匹配元素的文本内容 设置所有匹配元素的文本内容</desc>
         <signature/>
         <longdesc>结果是由所有匹配元素包含的文本内容组合起来的文本。这个方法对HTML和XML文档都有效。与 html() 类似, 但将编码 HTML (将 "&lt;" 和 "&gt;" 替换成相应的HTML实体).与 html() 类似, 但将编码 HTML (将 "&lt;" 和 "&gt;" 替换成相应的HTML实体).</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="text">
         <desc>取得所有匹配元素的内容。 设置所有匹配元素的文本内容 设置所有匹配元素的文本内容</desc>
         <signature>
            <argument name="textString">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index, text)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>结果是由所有匹配元素包含的文本内容组合起来的文本。这个方法对HTML和XML文档都有效。与 html() 类似, 但将编码 HTML (将 "&lt;" 和 "&gt;" 替换成相应的HTML实体).与 html() 类似, 但将编码 HTML (将 "&lt;" 和 "&gt;" 替换成相应的HTML实体).</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="html">
         <desc>取得第一个匹配元素的html内容。这个函数不能用于XML文档。但可以用于XHTML文档。 设置每一个匹配元素的html内容。这个函数不能用于XML文档。但可以用于XHTML文档。 设置每一个匹配元素的html内容。这个函数不能用于XML文档。但可以用于XHTML文档。</desc>
         <signature/>
         <longdesc>
            <p>This method is not available on XML documents.</p>
            <p>In an HTML document, we can use <code>.html()</code> to get the contents of any element. If the selector expression matches more than one element, only the first one's HTML content is returned. Consider this code:</p>
            <pre>$('div.demo-container').html();</pre>
            <p>In order for the following <code>&lt;div&gt;</code>'s content to be retrieved, it would have to be the first one with <code>class="demo-container"</code> in the document:</p>
            <pre>&lt;div class="demo-container"&gt;
  &lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt;
&lt;/div&gt;</pre>
            <p>The result would look like this:</p>
            <pre>&lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt;</pre>
            <p>This method uses the browser's <code>innerHTML</code> property. Some browsers may not return HTML that exactly replicates the HTML source in an original document. For example, Internet Explorer sometimes leaves off the quotes around attribute values if they contain only alphanumeric characters.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="html">
         <desc>取得第一个匹配元素的html内容。这个函数不能用于XML文档。但可以用于XHTML文档。 设置每一个匹配元素的html内容。这个函数不能用于XML文档。但可以用于XHTML文档。 设置每一个匹配元素的html内容。这个函数不能用于XML文档。但可以用于XHTML文档。</desc>
         <signature>
            <argument name="htmlString">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index, oldhtml)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>The <code>.html()</code> method is not available in XML documents. </p>
				        <p>When we use <code>.html()</code> to set elements' contents, any contents that were in those elements is completely replaced by the new contents. Consider the following HTML:</p>
				        <pre>&lt;div class="demo-container"&gt;
  &lt;div class="demo-box"&gt;Demonstration Box&lt;/div&gt;
&lt;/div&gt;</pre>
				        <p>We can set the HTML contents of <code>&lt;div class="demo-container"&gt;</code> like so:</p>
				        <pre>$('div.demo-container')
  .html('&lt;p&gt;All new content. &lt;em&gt;You bet!&lt;/em&gt;&lt;/p&gt;');</pre>
				        <p>That line of code will replace everything inside <code>&lt;div class="demo-container"&gt;</code>:</p>
				        <pre>&lt;div class="demo-container"&gt;
  &lt;p&gt;All new content. &lt;em&gt;You bet!&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;</pre>
            <p>As of jQuery 1.4, the <code>.html()</code> method allows us to set the HTML content by passing in a function.</p>
            <pre>$('div.demo-container').html(function() {
  var emph = '&lt;em&gt;' + $('p').length + ' paragraphs!&lt;/em&gt;';
  return '&lt;p&gt;All new content for ' + emph + '&lt;/p&gt;';
});</pre>
            <p>Given a document with six paragraphs, this example will set the HTML of <code>&lt;div class="demo-container"&gt;</code> to <code>&lt;p&gt;All new content for &lt;em&gt;6 paragraphs!&lt;/em&gt;&lt;/p&gt;</code>.</p>

         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="map">
         <desc>将一组元素转换成其他数组（不论是否是元素数组）</desc>
         <signature>
            <argument name="callback(index, domElement)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>你可以用这个函数来建立一个列表，不论是值、属性还是CSS样式，或者其他特别形式。这都可以用'$.map()'来方便的建立。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="is">
         <desc>用一个表达式来检查当前选择的元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>如果没有元素符合，或者表达式无效，都返回'false'。

'''注意：'''在jQuery 1.3中才对所有表达式提供了支持。在先前版本中，如果提供了复杂的表达式，比如层级选择器（比如 + , ~ 和 &gt; ），始终会返回true</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="eq">
         <desc>获取第N个元素</desc>
         <signature>
            <argument name="index">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="-index">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个元素的位置是从0算起。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="filter">
         <desc>筛选出与指定表达式匹配的元素集合。 筛选出与指定函数返回值匹配的元素集合</desc>
         <signature>
            <argument name="selector">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这个方法用于缩小匹配的范围。用逗号分隔多个表达式这个函数内部将对每个对象计算一次 (正如 '$.each'). 如果调用的函数返回false则这个元素被删除，否则就会保留。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="toggleClass">
         <desc>如果存在（不存在）就删除（添加）一个类。 如果开关switch参数为true则加上对应的class，否则就删除。 如果开关switch参数为true则加上对应的class，否则就删除。</desc>
         <signature>
            <argument name="className">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="className">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="switch">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index, class)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="switch">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>This method takes one or more class names as its parameter. In the first version, if an element in the matched set of elements already has the class, then it is removed; if an element does not have the class, then it is added. For example, we can apply <code>.toggleClass()</code> to a simple <code>&lt;div&gt;</code>: </p>
            <pre>&lt;div class="tumble"&gt;Some text.&lt;/div&gt;
      </pre>
            <p>The first time we apply <code>$('div.tumble').toggleClass('bounce')</code>, we get the following:</p>
            <pre>&lt;div class="tumble bounce"&gt;Some text.&lt;/div&gt;
      </pre>
            <p>The second time we apply <code>$('div.tumble').toggleClass('bounce')</code>, the <code>&lt;div&gt;</code> class is returned to the single <code>tumble</code> value:</p>
            <pre>&lt;div class="tumble"&gt;Some text.&lt;/div&gt;</pre>
            <p>Applying <code>.toggleClass('bounce spin')</code> to the same <code>&lt;div&gt;</code> alternates between <code>&lt;div class="tumble bounce spin"&gt;</code> and <code>&lt;div class="tumble"&gt;</code>.</p>
            <p>The second version of <code>.toggleClass()</code> uses the second parameter for determining whether the class should be added or removed. If this parameter's value is <code>true</code>, then the class is added; if <code>false</code>, the class is removed. In essence, the statement:</p>
            <pre>$('#foo').toggleClass(className, addOrRemove);</pre>
            <p>is equivalent to:</p>
            <pre>if (addOrRemove) {
    $('#foo').addClass(className);
  }
  else {
    $('#foo').removeClass(className);
  }
  </pre>
            <p>As of jQuery 1.4, the <code>.toggleClass()</code> method allows us to indicate the class name to be toggled by passing in a function.</p>
            <pre>$('div.foo').toggleClass(function() {
  if ($(this).parent().is('.bar')) {
    return 'happy';
  } else {
    return 'sad';
  }
});</pre>
            <p>This example will toggle the <code>happy</code> class for <code>&lt;div class="foo"&gt;</code> elements if their parent element has a class of <code>bar</code>; otherwise, it will toggle the <code>sad</code> class.</p>
  
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="removeClass">
         <desc>从所有匹配的元素中删除全部或者指定的类。 从所有匹配的元素中删除全部或者指定的类。</desc>
         <signature>
            <argument name="className">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index, class)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>If a class name is included as a parameter, then only that class will be removed from the set of matched elements. If no class names are specified in the parameter, all classes will be removed.</p>
				        <p>More than one class may be removed at a time, separated by a space, from the set of matched elements, like so:</p>
				        <pre>$('p').removeClass('myClass yourClass')
</pre>
				        <p>This method is often used with <code>.addClass()</code> to switch elements' classes from one to another, like so:</p>
				        <pre>$('p').removeClass('myClass noClass').addClass('yourClass');
</pre>
				        <p>Here, the <code>myClass</code> and <code>noClass</code> classes are removed from all paragraphs, while <code>yourClass</code> is added.</p>
				        <p>To replace all existing classes with another class, we can use <code>.attr('class', 'newClass')</code> instead.</p>
            <p>As of jQuery 1.4, the <code>.removeClass()</code> method allows us to indicate the class to be removed by passing in a function.</p>
            <pre>$('li:last').removeClass(function() {
          return $(this).prev().attr('class');
        });</pre>
            <p>This example removes the class name of the penultimate <code>&lt;li&gt;</code> from the last <code>&lt;li&gt;</code>.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="hasClass">
         <desc>检查当前的元素是否含有某个特定的类，如果有，则返回true。</desc>
         <signature>
            <argument name="className">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这其实就是 is("." + class)。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="removeAttr">
         <desc>从每一个匹配的元素中删除一个属性</desc>
         <signature>
            <argument name="attributeName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>The <code>.removeAttr()</code> method uses the JavaScript <code>removeAttribute()</code> function, but it has the advantage of being able to be called directly on a jQuery object and it accounts for different attribute naming across browsers.</p>
         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="attr">
         <desc>取得第一个匹配元素的属性值。通过这个方法可以方便地从第一个匹配元素中获取一个属性的值。如果元素没有相应属性，则返回 undefined 。 将一个“名/值”形式的对象设置为所有匹配元素的属性。 为所有匹配的元素设置一个属性值。 为所有匹配的元素设置一个计算的属性值。</desc>
         <signature>
            <argument name="attributeName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这是一种在所有匹配元素中批量设置很多属性的最佳方式。 注意，如果你要设置对象的class属性，你必须使用'className' 作为属性名。或者你可以直接使用.addClass( class ) 和 .removeClass( class ).不提供值，而是提供一个函数，由这个函数计算的值作为属性值。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="attr">
         <desc>取得第一个匹配元素的属性值。通过这个方法可以方便地从第一个匹配元素中获取一个属性的值。如果元素没有相应属性，则返回 undefined 。 将一个“名/值”形式的对象设置为所有匹配元素的属性。 为所有匹配的元素设置一个属性值。 为所有匹配的元素设置一个计算的属性值。</desc>
         <signature>
            <argument name="attributeName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="value">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="map">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="attributeName">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
            <argument name="function(index, attr)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>这是一种在所有匹配元素中批量设置很多属性的最佳方式。 注意，如果你要设置对象的class属性，你必须使用'className' 作为属性名。或者你可以直接使用.addClass( class ) 和 .removeClass( class ).不提供值，而是提供一个函数，由这个函数计算的值作为属性值。</longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
      <entry type="method" name="addClass">
         <desc>为每个匹配的元素添加指定的类名。 为每个匹配的元素添加指定的类名。</desc>
         <signature>
            <argument name="className">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <signature>
            <argument name="function(index, class)">
               <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
            </argument>
         </signature>
         <longdesc>
            <p>It's important to note that this method does not replace a class. It simply adds the class, appending it to any which may already be assigned to the elements.</p>
            <p>More than one class may be added at a time, separated by a space, to the set of matched elements, like so:</p>
            <pre>$('p').addClass('myClass yourClass');</pre>
            <p>This method is often used with <code>.removeClass()</code> to switch elements' classes from one to another, like so:</p>
            <pre>$('p').removeClass('myClass noClass').addClass('yourClass');</pre>
            <p>Here, the <code>myClass</code> and <code>noClass</code> classes are removed from all paragraphs, while <code>yourClass</code> is added.</p>
            <p>As of jQuery 1.4, the <code>.addClass()</code> method allows us to set the class name by passing in a function.</p>
            <pre>$('ul li:last').addClass(function() {
  return 'item-' + $(this).index();
});</pre>
            <p>Given an unordered list with five <code>&lt;li&gt;</code> elements, this example adds the class "item-4" to the last <code>&lt;li&gt;</code>.</p>


         </longdesc>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
         <example>
            <desc>xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</desc>
         </example>
      </entry>
   </entries>
</api>